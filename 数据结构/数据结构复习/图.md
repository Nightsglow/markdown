![image-20231114204242923](assets/image-20231114204242923.png)

![image-20231114204917599](assets/image-20231114204917599.png)

弧的起始顶点称为弧尾。终止顶点称为弧头。

![image-20231114205113729](assets/image-20231114205113729.png)

# 图的操作

![image-20231114213541978](assets/image-20231114213541978.png)
![image-20231114213609890](assets/image-20231114213609890.png)

# 邻接矩阵

![image-20231114211414022](assets/image-20231114211414022.png)

![image-20231114211454136](assets/image-20231114211454136.png)

![image-20231114212033220](assets/image-20231114212033220.png)

![image-20231114212043061](assets/image-20231114212043061.png)



# 邻接表

![image-20231114212132859](assets/image-20231114212132859.png)

![image-20231114212158960](assets/image-20231114212158960.png)

![image-20231114212253371](assets/image-20231114212253371.png)


# 十字链表

![image-20231114212443433](assets/image-20231114212443433.png)![image-20231114212451732](assets/image-20231114212451732.png)

# 邻接多重表

![image-20231114212815059](assets/image-20231114212815059.png)

# 图的遍历

## **深度优先遍历**DFS

![image-20231114213813434](assets/image-20231114213813434.png)
![image-20231114213952085](assets/image-20231114213952085.png)
![image-20231114214202703](assets/image-20231114214202703.png)
![image-20231114214346206](assets/image-20231114214346206.png)




## **广度优先遍历**BSF

邻接矩阵

![image-20231114214901844](assets/image-20231114214901844.png)

![image-20231114214945789](assets/image-20231114214945789.png)
邻接表

![image-20231114215021182](assets/image-20231114215021182.png)

# 生成树和最小生成树

对于一个有n个顶点的连通图G，其生成树包含了n-1条边，从而生成树是G的一个极小连通分量。

连通图的生成树不是唯一的

## 最小生成树

### Prim算法

### Kruskal算法

# 最短路径

## dijkstra算法

![image-20231018102510642](assets/image-20231018102510642.png)

![e97ccca93c70a5447236f60756371934](assets/e97ccca93c70a5447236f60756371934.jpeg)

- k为新加入集合的结点的下标
- D\[\]为路径长度
- p[]保存前驱结点
- s[]判断该节点是否已经加入集合

## Floyd算法

![image-20231127171203254](assets/image-20231127171203254.png)

- 某轮增加中间节点G（下标为g），A矩阵
  1. 对应行，只看第g列不为无穷的行，即该行对应结点能到G，记 I 到 G 的距离为 D~ig~ ，为了方便计算写在每一行前。
  2. 对于列，只看第g行值不为无穷的列，即G能到达的结点，记 G 到 J 的距离为 D~gj~  ，为了方便计算写在每一列上面。
  3. 对第二步选出的列，每一列中只看第一步选出的行，即前两部交叉标记的位置，对于位置 A~ij~ 比较该位置的值与D~ig~+D~gj~的大小，若D~ig~+D~gj~更小则替换。
  4. 更改Path矩阵，注意，某轮增加中间节点（下标为g）， I 到 J 有更短路径时，Path\[i\]\[j\]值改为Path\[g\]\[j\]的值，即将要改的从I到 J 的前驱结点改为从 G 到 J 的前驱结点（即Path\[g\]\[j\]的值）。

