# 欧几里得算法（扩展的）

求最大公因数 求最大公倍数 求逆元

求最大公因数 最大公倍数 也可以分解素因子

# 同余定理P21

# 同余式

# 同余式求解P30

![image-20231018203255593](assets/image-20231018203255593.png)

![image-20231018203145380](assets/image-20231018203145380.png)

# 第一章

系统的保密性不依赖于对加密体制或算法的保密，而依赖于密钥

明文消息空间、密文消息空间、加密变换、解密变换、密钥空间

密码体制分类：单钥体制、公钥体制

单钥体制：流密码、分组密码。

对密码系统的攻击类型：

1. 唯密文攻击
2. 已知明文攻击
3. 选择明文攻击
4. 选择密文攻击（攻击者所获信息量最大）

# 流密码

## 同步流密码

密钥流产生器、加密变换器

抗线性分析、抗统计分析

## 有限状态自动机

初始状态、序列（从左往右）、输出、状态转变，转移图、状态序列、输出序列

## 密钥流产生器



## 线性反馈移位寄存器（LFSR）

周期

n级线性移位反馈寄存器，**m序列：周期等于2^n^-1**

## 线性移位寄存器的一元多项式表示



递推关系。![image-20231023094228615](assets/image-20231023094228615.png)

LFSR的**特征多项式**：p(x)=1+c~1~x+c~2~x^2^+……+c~n-1~x^n-1^+c~n~x^n^

**G(p(x))**：n级线性移位寄存器的非恒零的2^n^-1个递推序列

给定序列{a~i~}，幂级数![image-20231022213434626](assets/image-20231022213434626.png)称为该序列的**生成函数**。

设p(x)=1+c~1~x+c~2~x^2^+……+c~n-1~x^n-1^+c~n~x^n^是GF(2)上的多项式，G(p(x))中任一序列{a~i~}的生成函数A(x)满足![image-20231022214849745](assets/image-20231022214849745.png)

p(x)|q(x)的充要条件G(p(x))⊂G(q(x))

设p(x)是GF(2)上的多项式，使p(x)|(x^p^-1)的最小p称为p(x)的周期或阶

若序列{a~i~}的特征多项式p(x)定义在GF(2)上，p使p(x)的周期，则{a~i~}的周期r|p。

仅能被非0常数或自身的常数倍除尽，但不能被其他多项式除尽的多项式称为即约多项式或不可约多项式

设p(x)是n次不可约多项式，周期为m，序列{a~i~}∈G(p(x))，则{a~i~}的周期为m。

n级LSFR产生的序列有最大周期2^n^-1的必要条件是其特征多项式不可约。

若n次不可约多项式p(x)的阶为2^n^-1，则p(x)是n次 本原多项式。

设{a~i~}∈G(p(x))，{a~i~}为m序列的充分条件是p(x)为本原多项式。

游程

GF(2)上周期为T的序列{a~i~}的自相关函数为![image-20231023092531595](assets/image-20231023092531595.png)

![image-20231023092544075](assets/image-20231023092544075.png)

![image-20231023092710465](assets/image-20231023092710465.png)

![image-20231023092746546](assets/image-20231023092746546.png)

## 非线性序列

### Geffe序列生成器

LFSR~i~的特征多项式分别为n~i~次本原多项式，且n~i~两两互素，则Geffe序列的周期为![image-20231023141427824](assets/image-20231023141427824.png)

![image-20231023141532782](assets/image-20231023141532782.png)

![image-20231023141630476](assets/image-20231023141630476.png)

### 利用JK触发器的非线性序列生成器

![image-20231023141733965](assets/image-20231023141733965.png)

![image-20231023141743097](assets/image-20231023141743097.png)

![image-20231023141934037](assets/image-20231023141934037.png)

![image-20231023142409523](assets/image-20231023142409523.png)![image-20231023142420734](assets/image-20231023142420734.png)

![image-20231023143613629](assets/image-20231023143613629.png)

### Pless生成器

![image-20231023150041906](assets/image-20231023150041906.png)

### 钟控序列生成器

![image-20231023150159863](assets/image-20231023150159863.png)

# 分组密码体制

![image-20231024200607989](assets/image-20231024200607989.png)

DES采用56比特密钥、IDEA采用128比特密钥

## 代换

![image-20231024200711302](assets/image-20231024200711302.png)

![image-20231024200726102](assets/image-20231024200726102.png)

S盒

![image-20231024200831601](assets/image-20231024200831601.png)

## 代换和置换

- 代换：将明文字符替换成其他的字母、数字或符号

  如果明文和密文的分组长都为n比特，则明文的每一个分组都有2^n^个可能的取值。为使加密运算可逆，明文的每一个分组都应产生唯一的一个密文分组，这样的变换是可逆的，称明文分组到密文分组的可逆变换为代换。不同可逆变换的个数有2^n^！个

- 置换：明文的字母相同，但被打乱了

代换密码是将明文字母用不同的密文字母代替，生成的密文中可能有明文未包含的字母，而置换密码是仅仅打乱明文字母的位置和顺序

## 扩散和混淆

目的是抗击敌手对密码系统的统计分析。

**扩散，就是将明文的统计特性散布到密文中去**，实现方式是使得密文中每一位由明文中多位产生。

扩散的目的是使明文和密文之间的统计关系变得尽可能复杂，以使敌手无法得到密钥。

**混淆是使密文和密钥之间的统计关系变得尽可能复杂**，以使敌手无法得到密钥。因此即使敌手能得到密文的一些统计关系，由于密钥和密文之间统计关系复杂化，敌手无法得到密钥。使用复杂的代换算法可得预期的混淆效果，而简单的线性代换函数得到的混淆效果不够理想。

## Feistel密码结构

Feistel提出利用**乘积密码**可获得简单的代换密码。乘积密码指顺序地执行两个或多个基本密码系统，使得最后结果的密码强度高于每个基本密码系统产生的结果。

![image-20231024201716825](assets/image-20231024201716825.png)

![image-20231024201724748](assets/image-20231024201724748.png)

Feistel网络的实现与以下参数和特性有关：
(1)分组大小。分组越大则安全性越高，但加密速度就越慢。分组密码设计中最为普遍使用的分组大小是64比特。
(2)密钥大小。密钥越长则安全性越高，但加密速度就越慢。现在普遍认为64比特或更短的密钥是不安全的，通常使用128比特长的密钥。(3)轮数。单轮结构远不足以保证安全性，多轮结构可提供足够的安全性。典型地，轮数取为16。
(4)子密钥产生算法。该算法的复杂性越高，则密码分析的困难性就越大。
(5)轮函数。轮函数的复杂性越高，密码分析的困难性也越大。

在设计Feistel网络时，还要考虑以下两个问题：
(1)快速的软件实现。在很多情况下，算法是被镶嵌在应用程序中，因而无法用硬件实现。此时算法的执行速度是考虑的关键。
(2)算法容易分析。如果算法能被无疑义地解释清楚，就可容易地分析算法抵抗攻击的能力，有助于设计高强度的算法。

![image-20231024201845568](assets/image-20231024201845568.png)

![image-20231024202227925](assets/image-20231024202227925.png)

![image-20231024202223120](assets/image-20231024202223120.png)

## 数据加密标准（DES）

分组长度64比特
密钥长度56比特

三个阶段：

1. 初始置换IP
2. 16轮变换
3. 逆初始

从而产生64比特的密文。

密钥首先通过一个置换函数，然后，对加密过程的每一轮，通过一个左循环移位和一个置换产生一个子密钥。其中每轮的置换都相同，但由于密钥被重复迭代，所以每轮产生的子密钥都不相同。

![image-20231024204236191](assets/image-20231024204236191.png)

### 初始置换

初始置换输入64bit，每一位bit按其位对应表中的数值进行移位，如第1位换到第58位，第二位换到第50位

![image-20231024204308474](assets/image-20231024204308474.png)

![image-20231024204342335](assets/image-20231024204342335.png)

![image-20231024204352636](assets/image-20231024204352636.png)

### 轮结构

![image-20231024210010929](assets/image-20231024210010929.png)

![image-20231024210025244](assets/image-20231024210025244.png)

扩展将32比特变为48比特。

![image-20231024210700290](assets/image-20231024210700290.png)

![image-20231024210706272](assets/image-20231024210706272.png)

8个S盒，每个S盒的输入为6比特，输出为4比特。八个S盒一共48比特输入后输出一共32比特。

![image-20231024211011954](assets/image-20231024211011954.png)

![image-20231024211121223](assets/image-20231024211121223.png)

### 密钥的产生

56比特密钥先经过一个置换运算。

分两部分，进入轮函数，各进行循环左移位，移位位数由表给出，得到的输出①作为下一轮输入；②进行置换选择2后作为本轮子密钥。

![image-20231024211246324](assets/image-20231024211246324.png)

![image-20231024210010929](assets/image-20231024210010929.png)

![image-20231024211349991](assets/image-20231024211349991.png)

![image-20231024211401468](assets/image-20231024211401468.png)

### 解密

和Feistel密码一样，DES的解密和加密使用同一算法，但子密钥使用的顺序相反。

### 二重DES

![image-20231024212153604](assets/image-20231024212153604.png)

**二重DES产生的映射不会等价于单重DES加密。**

#### 中途相遇攻击

但对二重DES有以下一种称为**中途相遇攻击**的攻击方案，已知明文密文对![image-20231024212445539](assets/image-20231024212445539.png)

### 两个密钥的三重DES

![image-20231024213203675](assets/image-20231024213203675.png)

### 3个密钥的三重DES

![image-20231024213301296](assets/image-20231024213301296.png)

![image-20231024213305911](assets/image-20231024213305911.png)

## 差分密码分析

差分密码分析的基本思想：通过分析明文对的差值对密文对的差值的影响来恢复某些密钥比特。

一种攻击的复杂度可以分为两部分：**数据复杂度**和**处理复杂度**。数据复杂度是实施该攻击所需输人的数据量；处理复杂度是处理这些数据所需的计算量。这两部分主要用来刻画该攻击的复杂度。

## 线性密码分析

线性密码分析是对迭代密码的一种已知明文攻击，它利用的是密码算法中的“不平衡（有效）的线性逼近”。

## 分组密码的运行模式

![image-20231024214031325](assets/image-20231024214031325.png)

### 电码本(ECB)模式

（**Electronic codebook**，ECB）

一次对一个64比特长的明文分组加密，而且**每次的加密密钥都相同**，

如图3-10所示。当密钥取定时，对明文的每一个分组，都有一个唯一的密文与之对应。因此可以形象地认为有一个非常大的
电码本，对任意一个可能的明文分组，电码本中都有一项与之对应的密文。

如果消息长于64比特，则将其分为长为64比特的分组，最后一个分组如果不够64比特，则需要**填充**。

解密过程也是一次对一个分组解密，而且每次解密都使用同一密钥。

![image-20231024214651823](assets/image-20231024214651823.png)

ECB在用于短数据（如加密密钥）时非常理想，因此如果需要安全地传递DES密钥，ECB是最合适的模式。

ECB的最大特性是若同一明文分组在消息中重复出现，则产生的密文分组也相同。

ECB用于长消息时可能不够安全，如果消息有固定结构，密码分析者有可能找出这种关系。例如，如果已知消息总是以某个预定义字段开始，那么分析者就可能得到很多明文密文对。如果消息有重复的元素而重复的周期是64的倍数，那么密码分析者就能够识别这些元素。以上这些特性都有助于密码分析者，有可能为其提供对分组的代换或重排的机会。

### 密码分组链接（CBC）模式

为了解决ECB的安全缺陷，可以让重复的明文分组产生不同的密文分组，密码分组链接(**Cipher Block Chaining**,CBC)模式就可满足这一要求。
图3-11是CBC模式的示意图，它一次对一个明文分组加密，**每次加密使用同一密钥，加密算法的输入是当前明文分组和前一次密文分组的异或**，因此加密算法的输入不会显示出与这次的明文分组之间的固定关系，所以重复的明文分组不会在密文中暴露出这
种重复关系。
解密时，每一个密文分组被解密后，再与前一个密文分组异或，即：

![image-20231024214945646](assets/image-20231024214945646.png)

因而产生出明文分组。
在产生第一个密文分组时，需要有一个初始向量V与第一个明文分组异或。解密时，IV和解密算法对第一个密文分组的输出进行异或以恢复第一个明文分组。

![image-20231024214922890](assets/image-20231024214922890.png)

IV对于收发双方都应是已知的，为使安全性最高，**IV应像密钥一样被保护，可使用ECB加密模式来发送IV**。保护IV的原因如下：如果敌手能欺骗接收方使用不同的IV值，敌手就能够在明文的第一个分组中插入自己选择的比特值，这是因为：
![image-20231024215048460](assets/image-20231024215048460.png)
用X(i)表示64比特分组X的第i个比特，那么![image-20231024215117572](assets/image-20231024215117572.png),由异或的性质得：
![image-20231024215135074](assets/image-20231024215135074.png)

其中撇号表示比特补。上式意味着如果敌手篡改了IV中的某些比特，则接收方收到的P~1~中相应的比特也发生变化。

由于CBC模式的链接机制，CBC模式对加密长于64比特的消息非常合适。

CBC模式除能够获得保密性外，还能用于**认证**。

### 密码反馈(CFB)模式

如上所述，DES是分组长为64比特的分组密码，但**利用密码反馈(Cipher FeedBack,CFB)模式或输出反馈模式(OFB)模式可将DES转换为流密码**。流密码不需要对消息填充，而且运行是实时的。因此如果传送字母流，可使用流密码对每个字母直接加密并传送。
流密码具有密文和明文一样长这一性质，因此，如果需要发送的每个字符长为8比特，就应使用8比特密钥来加密每个字符。如果密钥长超过8比特，则造成浪费。
图3-12是CFB模式示意图，设传送的每个单元（如一个字符）是j比特长，通常取j=8,与CBC模式一样，明文单元被链接在一起，使得密文是前面所有明文的函数。
![image-20231024215409472](assets/image-20231024215409472.png)

加密时，加密算法的输入是64比特移位寄存器，其初值为某个初始向量IV。加密算法输出的最左（最高有效位）j比特与明文的第一个单元P~1~异或，产生出密文的第一个单元C~1~,并传送该单元。然后将移位寄存器的内容左移j位并将C~1~送入移位寄存器最右边（最低有效位）j位。这一过程继续到明文的所有单元都被加密为止。解密时，将收到的密文单元与加密函数的输出进行异或。注意这时仍然使用加密算
法而不是解密算法，原因如下：
设S,(X)是X的j个最高有效位，那么![image-20231024215603220](assets/image-20231024215603220.png),因此![image-20231024215620132](assets/image-20231024215620132.png)可证明以后各步也有类似的这种关系。

CFB模式除能获得保密性外，还能用于认证。

### 输出反馈（OFB）模式

输出反馈(Output FeedBack,OFB)模式的结构类似于CFB,如图3-l3所示。不同之处如下：**OFB模式是将加密算法的输出反馈到移位寄存器，而CFB模式是将密文单元反馈到移位寄存器。**

![image-20231024220031545](assets/image-20231024220031545.png)

OFB模式的优点是**传输过程中的比特错误不会被传播。**例如，C~1~中出现一比特错误，在解密结果中只有P~1~受到影响，以后各明文单元则不受影响。而在CFB中，C~1~也作为移位寄存器的输人，因此它的一比特错误会影响解密结果中各明文单元的值。
OFB的缺点是它**比CFB模式更易受到对消息流的篡改攻击**，例如在密文中取1比特的补，那么在恢复的明文中相应位置的比特也为原比特的补。因此使得敌手有可能通过对消息校验部分的篡改和对数据部分的篡改，而以纠错码不能检测的方式篡改密文。

### 计数器（CRT）模式

CTR模式全称CounTeR模式（计数器模式）。CTR模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。

![img](assets/70.png)
CTR模式中，每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密而得到的比特序列，与明文分组进行XOR而得到的。



二 、计数器的生成方法

每次加密时都会生成一个不同的值（nonce）作为计数器的初始值。当分组长度为128比特时，计数器的初始值可能如下图所示：

加密过程中，计数器的值会产生如下变化：



三 、OFB模式与CTR模式的对比

CTR模式和OFB模式都属于流密码。

OFB模式是将加密的输出反馈到输入，而CTR模式则是将计数器的值用作输入。



四 、CTR模式的特点

CTR模式的加密和解密使用了完全相同的模式，因此在程序上实现上比较容易。

CTR模式中可以以任意顺序对分组进行加密和解密，因为在加密和解密时需要用到的“计数器”的值可以由nonce和分组序号直接计算出来。

能够以任意顺序处理分组，意味着能够实现并行计算。在支持并行计算的系统中，CTR模式的速度是非常快的。



### 错误传播

1. 若**传输密文C~1~时**发生了错误，则这个错误最多影响多少个明文分组

   - 电码本模式（ECB）：密文分组C~1~的1bit错误仅影响当前明文分组（共影响1个）
   - 密码分组链接模式（CBC）：密文分组C~1~的1bit错误影响当前明文分组和下一个明文分组（共影响2个）
   - 密码反馈模式（CFB）：密文分组C~1~的1bit错误影响当前和之后的64/j个明文分组（一般情况下IV在移位寄存器的移位位数j为8，故共影响1 + 64/j = 9 个）
   - 输出反馈模式（OFB）：密文分组C~1~的1bit错误仅影响当前明文分组（共影响1个）
   - 计数器模式（CRT）：密文分组C~1~的1bit错误仅影响当前明文分组（共影响1个）

2. 若**加密明文分组P~1~时**有一位发生了错误，则这个错误至多扩散至多少个密文分组？解密后有几个明文分组会发生错误？

   - 电码本模式（ECB）：明文分组P~1~的1bit错误仅影响当前密文分组，无错误传播。
   - 密码分组链接模式（CBC）：明文分组P~1~的1bit错误仅影响当前密文分组，无错误传播。
   - 密码反馈模式（CFB）：明文分组P~1~的1bit错误错误影响当前和之后的全部密文分组
   - 输出反馈模式（OFB）：明文分组P~1~的1bit错误仅影响当前密文分组，无错误传播。
   - 计数器模式（CTR）：明文分组P~1~的1bit错误仅影响当前密文分组，无错误传播。

   - **都是仅在当前明文分组发生错误**

   


## AES算法 ----- Rijndael

![image-20231025085541378](assets/image-20231025085541378.png)

![image-20231025085701784](assets/image-20231025085701784.png)

![image-20231025085933820](assets/image-20231025085933820.png)

![image-20231025085944779](assets/image-20231025085944779.png)

宽轨迹策略：轮函数中三个层
![image-20231025090519680](assets/image-20231025090519680.png)

### 算法说明

迭代型分组密码，分组长度和密钥长度都可变，各自可以独立的指定为**128比特，192比特，256比特**。

![image-20231025090643753](assets/image-20231025090643753.png)

### 轮函数

字节代换、行位移、列混合、密钥加

其中最后一轮没有列混合

#### 字节代换

**非线性代换**

代换表（S盒）是可逆的。

![image-20231025091022067](assets/image-20231025091022067.png)

#### 行位移

是将状态阵列的各行进行循环位移，不同状态行的位移量不同。第0行不移动，第1行循环左移C~1~个字节，第2行循环左移C~2~个字节，第3行循环左移C~3~个字节。位移量C~1~、C~2~、C~3~的取值与N~b~有关。



![image-20231025091311686](assets/image-20231025091311686.png)

![image-20231025091618811](assets/image-20231025091618811.png)

#### 列混合

![image-20231025091646434](assets/image-20231025091646434.png)


![image-20231025091849916](assets/image-20231025091849916.png)

#### 密钥加

![image-20231025092300441](assets/image-20231025092300441.png)

### 密钥编排

![image-20231025092448771](assets/image-20231025092448771.png)

### 加密算法

![image-20231025092608031](assets/image-20231025092608031.png)

![image-20231025092617995](assets/image-20231025092617995.png)
![image-20231025092629604](assets/image-20231025092629604.png)

### 解密算法

![image-20231025092733392](assets/image-20231025092733392.png)

# 公钥密码

## 群环域

半群：封闭性、结合律

群：有单位元、每个元素都有逆元、封闭性、结合律

群的阶：有限群中，G的元素个数

交换群（Abel群）：满足交换律

循环群：

循环群的生成元：

![image-20231026145931651](assets/image-20231026145931651.png)

环：

![image-20231026150105047](assets/image-20231026150105047.png)

域：

![image-20231026150241288](assets/image-20231026150241288.png)

![image-20231026150308584](assets/image-20231026150308584.png)

多项式

![image-20231026150417347](assets/image-20231026150417347.png)![image-20231026150424174](assets/image-20231026150424174.png)

## 素数

![image-20231026151118066](assets/image-20231026151118066.png)

![image-20231026151126266](assets/image-20231026151126266.png)![image-20231026151133769](assets/image-20231026151133769.png)![image-20231026151140441](assets/image-20231026151140441.png)

![image-20231026151155253](assets/image-20231026151155253.png)

![image-20231026151213265](assets/image-20231026151213265.png)

![image-20231026151218845](assets/image-20231026151218845.png)

![image-20231026151231323](assets/image-20231026151231323.png)

![image-20231026151523813](assets/image-20231026151523813.png)

![image-20231026151738619](assets/image-20231026151738619.png)

![image-20231026151748328](assets/image-20231026151748328.png)

**lcm是最小公倍数**

![image-20231026151914444](assets/image-20231026151914444.png)

![image-20231026152114557](assets/image-20231026152114557.png)

## 素性检验

AKS算法

![image-20231026161742847](assets/image-20231026161742847.png)

![image-20231026161801514](assets/image-20231026161801514.png)



## 循环群

![image-20231026152305380](assets/image-20231026152305380.png)

![image-20231026152313272](assets/image-20231026152313272.png)

![image-20231026152324239](assets/image-20231026152324239.png)

![image-20231026152337259](assets/image-20231026152337259.png)

![image-20231026152345907](assets/image-20231026152345907.png)

![image-20231026152413612](assets/image-20231026152413612.png)

![image-20231026152431901](assets/image-20231026152431901.png)

## 离散对数

![image-20231026195605695](assets/image-20231026195605695.png)

![image-20231026195617100](assets/image-20231026195617100.png)
![image-20231026195648126](assets/image-20231026195648126.png)
![image-20231026195658606](assets/image-20231026195658606.png)

![image-20231026200049715](assets/image-20231026200049715.png)





## 公钥密码体制基本概念

一方面，公钥密码算法的基本工具不再是代换和置换，而是数学函数；

另一方面，公钥密码算法以非对称的形式使用两个密钥，两个密钥的使用对保密性、密钥分配、认证等都有着深刻的意义。

### 公钥密码体制的基本原理

公钥密码算法最大的特点是采用两个相关密钥将加密和解密能力分开，其中一个密钥是公开的，称为公开密钥，简称公开钥，用于加密；另一个密钥是为用户专用，因而是保密的，称为秘密密钥，简称秘密钥，用于解密。因此公钥密码体制也成为双钥密码体制。

算法有以下特征：已知密码算法和加密密钥，求解密密钥在计算上是不可行的。

### 加密

![image-20231026154114199](assets/image-20231026154114199.png)

### 认证

![image-20231026154130425](assets/image-20231026154130425.png)

![image-20231026154202907](assets/image-20231026154202907.png)

### 认证与加密

![image-20231026154218922](assets/image-20231026154218922.png)

### 公钥密码算法的要求（单向函数与陷门单向函数）

![image-20231026154759731](assets/image-20231026154759731.png)

![image-20231026154812888](assets/image-20231026154812888.png)

公钥密码体制目前主要用于 密钥管理 和 数字签字。

## RSA算法

### 密钥的产生

![image-20231026155727363](assets/image-20231026155727363.png)

### 加密解密

![image-20231026161204648](assets/image-20231026161204648.png)

### 密钥的产生

寻找大素数。

寻找大素数时一般先随机选取一个大的奇数（如用伪随机数产生器），然后用素性检验算法检验这一奇数是否为素数。

RSA的安全性是基于分解大整数的困难性假定

为了保证算法的安全性，还对p和q提出以下要求：

![image-20231026163312942](assets/image-20231026163312942.png)

![image-20231026163322997](assets/image-20231026163322997.png)

### 对RSA的攻击

RSA存在以下两种攻击，并不是因为算法本身存在缺陷，而是由于参数选择不当造成的。

#### 共模攻击

![image-20231026163827481](assets/image-20231026163827481.png)

#### 低指数攻击

![image-20231026164319295](assets/image-20231026164319295.png)
由中国剩余定理可求出m^3^(mod n~1~n~2~n~3~)。由于m^3^< n~1~n~2~n~3~，可直接由m^3^开立方根得到m。

## 背包密码体制

![image-20231026185911194](assets/image-20231026185911194.png)

![image-20231026185230860](assets/image-20231026185230860.png)![image-20231026185236479](assets/image-20231026185236479.png)

![image-20231026185249342](assets/image-20231026185249342.png)

## Rabin密码体制

![image-20231026192627212](assets/image-20231026192627212.png)

![image-20231026193000010](assets/image-20231026193000010.png)

![IMG_20231026_192834](assets/IMG_20231026_192834.jpg)

![image-20231026193136524](assets/image-20231026193136524.png)

![image-20231026193149523](assets/image-20231026193149523.png)

## ElGamal密码体制

![IMG_20231030_154843](assets/IMG_20231030_154843.jpg)
![aa3737ee81e527f9aef596912dbe6bea](assets/aa3737ee81e527f9aef596912dbe6bea.jpeg)

## 椭圆曲线

![image-20231027092903876](assets/image-20231027092903876.png)
![image-20231027092919659](assets/image-20231027092919659.png)
![image-20231027092932377](assets/image-20231027092932377.png)
![image-20231027092950554](assets/image-20231027092950554.png)
![image-20231027093008217](assets/image-20231027093008217.png)![image-20231027093017329](assets/image-20231027093017329.png)

![image-20231027093029304](assets/image-20231027093029304.png)

![image-20231027111713696](assets/image-20231027111713696.png)

![image-20231027111720526](assets/image-20231027111720526.png)

### 求所有点

![image-20231104201728779](assets/image-20231104201728779.png)

# 密钥分配与密钥管理

KDC：密钥分配中心

密钥的分层控制：分层结构可减少主密钥的分布、还可以将虚假KDC的危害限制到一个局部区域

会话密钥有效期

## 无中心的密钥控制

![image-20231028101203768](assets/image-20231028101203768.png)
![image-20231028101211904](assets/image-20231028101211904.png)

## 密钥的控制使用

![image-20231028101353544](assets/image-20231028101353544.png)
![image-20231028101402771](assets/image-20231028101402771.png)
![image-20231028101415517](assets/image-20231028101415517.png)

## 公钥加密体制的密钥管理

### 公钥的分配方法

1. 公开发布

2. 公用目录表

   ![image-20231028101946458](assets/image-20231028101946458.png)

3. 公钥管理机构

   ![image-20231028102057200](assets/image-20231028102057200.png)
   ![image-20231028102105686](assets/image-20231028102105686.png)

4. 公钥证书

   ![image-20231028102215472](assets/image-20231028102215472.png)
   ![image-20231028102337960](assets/image-20231028102337960.png)

### 中间人攻击

### 具有保密性和认证性的密钥分配

![image-20231028102521850](assets/image-20231028102521850.png)

## Diffe-Hellman密钥交换

![image-20231028102705370](assets/image-20231028102705370.png)

![image-20231028102715579](assets/image-20231028102715579.png)

## 秘密分割

设秘密s被分成n个部分信息，每一部分信息称为一个子密钥或影子，由一个参与者持有，使得：①由k个或多余k个参与者所持有的部分信息可重构s；②由少于k个参与者所持有的部分信息则无法重构s。
称这种方案为(k,n)-秘密分割门限方案，k称为方案的门限值。

如果一个参与者或一组未经授权的参与者在猜测秘密s时，并不比局外人猜秘密时有优势，则称这个方案是完善的，即(k,n)-秘密分割门限方案是完善的。

③由少于k个参与者所持有的部分信息得不到秘密s的任何信息。

### Shamir门限方案

![image-20231028104115604](assets/image-20231028104115604.png)

基于多项式的Lagrange插值公式。

![image-20231028103819171](assets/image-20231028103819171.png)
![image-20231028103851493](assets/image-20231028103851493.png)

![image-20231028103914891](assets/image-20231028103914891.png)


### 基于中国剩余定理的门限方案

![image-20231028110055583](assets/image-20231028110055583.png)
![image-20231028110111189](assets/image-20231028110111189.png)
![image-20231028110128816](assets/image-20231028110128816.png)
![image-20231028110138425](assets/image-20231028110138425.png)



# 消息认证和哈希函数

消息认证是一个过程，用于验证接收消息的**真实性和完整性**，同时还用于验证消息的**顺序性和时间性**。除此之外，在考虑网络安全时还需考虑业务的**不可否认性**。实现消息的不可否认性可通过**数字签字**，数字签字也是一种**认证技术**，也可用于**抗击主动攻击**。

消息认证机制和数字签字极值都有一产生**认证符**的基本功能，这一基本功能又作为认证协议的一个组成部分。认证符是用于认证消息的数值，它的产生方法分为**消息认证码（MAC）、哈希函数（Hash Function）**两大类。

## 消息认证码（MAC）

**消息认证码**是指消息被一个**密钥**控制的公开函数作用后产生的、用作认证符的、固定长度的数值，也称为**密码校验和**。

### 消息认证码的定义及使用方式

通信双方A和B共享一密钥K。设A欲发送给B的消息是M，A首先计算MAC=C~k~(M)，其中C~k~(·)是密钥控制的公开函数，然后向B发送M||MAC，B收到后做与A相同的计算，求得一个新的MAC，并与收到MAC做比较。

![image-20231029161108333](assets/image-20231029161108333.png)
通常希望直接对明文进行认证，因此b所示的使用方式更为常用

### 产生MAC函数应满足的要求

穷搜索攻击

产生MAC的函数一般为多到一映射

两种攻击：对密钥的攻击、对消息的攻击

### 数据认证算法

![image-20231029163159329](assets/image-20231029163159329.png)
![image-20231029163205947](assets/image-20231029163205947.png)

## 哈希函数

**哈希函数**H是一公开函数，用于将任意长的消息M映射为较短、固定的一个值H(M)，作为认证符，称函数值H(M)为**哈希值**或**哈希码**或**消息摘要**。

哈希码是消息中所有比特的函数，因此提供了一种错误检测能力。

**基本使用方法**：

1. 消息与哈希码链接后用单钥加密算法加密。保证消息来自A并且未被篡改，同时还提供保密性。
2. 用单钥加密算法仅对哈希码加密。
3. 用公钥加密算法和发方的秘密钥仅加密哈希码。数字签字。
4. 用公钥加密算法和发方的秘密钥加密后与消息链接，再对链接后的结果用单钥加密算法加密，这种方式提供了保密性和数字签字
5. 使用这种方式时要求通信双方共享一个秘密值S，A计算消息M和秘密值S链接在一起的哈希值，并将此哈希值附加到M后发往B。
6. 比(5)增加单钥加密。

![image-20231029165620367](assets/image-20231029165620367.png)
![image-20231029165631103](assets/image-20231029165631103.png)

哈希函数应满足的条件：

1. 输入任意长
2. 输出定长
3. 已知x求H(x)较为容易
4. 已知h，求使得H(x)=h的x在计算上是不可行的，单向性
5. 已知x，找出y(y≠x)使得H(x)=H(y)在计算上是不可行的。
6. 找出任意两个不同的输入x、y，使得H(x)=H(y)在计算上是不可行的。

前三个是基本要求



### 生日攻击

#### 相关问题

![image-20231029170213549](assets/image-20231029170213549.png)

#### 生日悖论

![image-20231029170233280](assets/image-20231029170233280.png)
![image-20231029170245860](assets/image-20231029170245860.png)

#### 生日攻击

![image-20231029171139162](assets/image-20231029171139162.png)

### 迭代型哈希函数的一般结构

MD5、SHA，结构都是迭代型。

输入分组、填充、最后一个分组还包括整个函数输入的长度值。

压缩函数f

链接分组

![image-20231029171553140](assets/image-20231029171553140.png)

## MD5哈希算法

算法的**输入为任意长**的消息，分为**512比特长的分组，输出为128比特的消息摘要**。

![image-20231029172418662](assets/image-20231029172418662.png)

### 处理过程

#### 1、对消息填充

对消息填充，使得其比特长度**在模512下为448**，即填充后消息的长度为512的某一倍数减64，留出的64比特用于附加消息的长度使用。

**即使消息的长度已经满足要求，仍需填充。**例如，消息长度为448，则需填充512比特，使其长度变为960，因此填充的比特数大于等于1而小于等于512。

填充方式：**第一位为1，其后各位皆为0。**

#### 2、附加消息的长度

用步骤一中留出的64比特以**小端方式**来表示消息被填充前的长度。如果消息长大于2^64^，则以2^64^为模数取模。

小端方式是指数据按最低有效字节（byte）（或最低有效位）优先的顺序存储数据，即将**最低有效字节（或最低有效位）存于低地址字节（或位）**。相反的存储方式为大端方式。

#### 3、对MD缓冲区初始化

算法使用128比特长的缓冲区以存储中间结果和最终哈希值，缓冲区可表示为4个32比特长的寄存器（A，B，C，D），每个寄存器都以小端方式存储数据，其初值取为（以存储方式）A=01234567、B=89ABCDEF、C=FEDCBA98、D=76543210，实际上为67452301，EFCDAB89、98BADCFE、10325476

#### 4、以分组为单位对消息进行处理（4轮*16步迭代）

每一分组Y~q~（q=0，···，L-1）都经过一压缩函数H~MD5~处理。H~MD5~是算法的核心，其中又有**4轮处理**过程，如图6-7。
![image-20231029190022222](assets/image-20231029190022222.png)
![image-20231029190032077](assets/image-20231029190032077.png)
![image-20231029190050444](assets/image-20231029190050444.png)

#### 5、输出

消息的L个分组都被处理完后，最后一个H~MD5~的输出即为产生的消息摘要。

#### 总结：

![image-20231029190455691](assets/image-20231029190455691.png)

### MD5的压缩函数

压缩函数H~MD5~中有4轮处理过程，每轮又对缓冲区ABCD进行**16步迭代**运算，每一步的运算形式如下：

![image-20231029190633520](assets/image-20231029190633520.png)
![image-20231029190736091](assets/image-20231029190736091.png)![image-20231029190718984](assets/image-20231029190718984.png)

## 安全哈希算法 SHA

基于MD4算法

### 算法描述

算法的输入为小于2^64^比特长的任意消息，分为512比特长的分组，输出为160比特长的消息摘要。

算法的框图与MD5的算法图一样，但哈希值的长度和链接变量的长度为160比特。

![image-20231029172418662](assets/image-20231029172418662.png)

### 算法的处理过程有以下几步：

#### 1、对消息的填充。

与MD5的步骤1完全相同

#### 2、附加消息的长度。

与MD5的步骤2类似，不同之处在于以大端方式表示填充前消息的长度。即步骤1留出的64比特当做64比特长的无符号整数。

#### 3、对MD缓冲区初始化。

算法使用160比特长的缓冲区存储中间结果和最终哈希值，缓冲区可表示为5个32比特长的寄存器（A，B，C，D，E），每个寄存器都以大端方式存储数据，其初始值为A=67452301，B=EFCDAB89，C=98BADCFB，D=10325476，E=C3D2E1F0。

#### 4、以分组为单位进行处理。（4轮*20步迭代）

![image-20231029193500768](assets/image-20231029193500768.png)

#### 5、输出。

消息的L个分组都被处理完成后，最后一个分组的输出即为160比特的消息摘要

#### 总结

![image-20231029193648891](assets/image-20231029193648891.png)

### SHA的压缩函数

![image-20231029193721688](assets/image-20231029193721688.png)
![image-20231029193937894](assets/image-20231029193937894.png)
![image-20231029193950713](assets/image-20231029193950713.png)
![image-20231029194008364](assets/image-20231029194008364.png)

### SHA与MD5比较

![image-20231029194131072](assets/image-20231029194131072.png)

## HMAC

基于密码哈希函数的构造方法

在IPSec和其他网络协议（如SSL）中得以应用。

![image-20231029195126409](assets/image-20231029195126409.png)

![image-20231029194640841](assets/image-20231029194640841.png)
![image-20231029194652846](assets/image-20231029194652846.png)

![image-20231029194709563](assets/image-20231029194709563.png)
![image-20231029194724387](assets/image-20231029194724387.png)

#### 安全性

![image-20231029195525453](assets/image-20231029195525453.png)

![image-20231029195538459](assets/image-20231029195538459.png)

## CBC-MAC 算法

![image-20231029195636963](assets/image-20231029195636963.png)

# 数字签名和认证协议

![image-20231030084102810](assets/image-20231030084102810.png)

## 数字签名产生方式

### 一、由加密算法产生数字签名

利用加密算法产生数字签名是指将消息或消息的摘要加密后的密文作为对该消息的数字签名，其用法有根据单钥加密还是公钥加密有所不同。

![image-20231030084558999](assets/image-20231030084558999.png)

### 二、由签名算法产生数字签名

![image-20231030084630437](assets/image-20231030084630437.png)

## 数字签名的执行方式

### 1、直接方式

直接方式是指数字签名的执行过程只有通信双方参与，并假定双方有共享的秘密钥或接收一方知道发送方的公开钥。

### 2、具有仲裁方式的数字签名

发送方X对发往收方Y的消息签名后，将消息及其签名先发给仲裁者A，A对消息及其签名验证完毕后，再连同一个表示已通过验证的指令一起发往接收方Y。

仲裁者起着重要作用，并应取得所有用户的信任。
![image-20231030085952139](assets/image-20231030085952139.png)

#### 例7-1

![image-20231030085846855](assets/image-20231030085846855.png)

#### 例7-2

![image-20231030090500702](assets/image-20231030090500702.png)

#### 例7-3

![image-20231030092504066](assets/image-20231030092504066.png)

## 数字签名标准DSS

### DSS的基本方式

RSA算法既能用于加密和签名又能用于密钥交换，与RSA算法相比DSS使用的算法只提供数字签名功能，

![image-20231030144651028](assets/image-20231030144651028.png)
采用RSA签名时，将消息输入到一个哈希函数以产生一个固定长度的安全哈希值，再用发送方的秘密钥加密哈希值就形成了对消息的签名。消息及其签名被一起发送给接收方，接收方得到消息后再产生出消息的哈希值，且使用发送方的公开钥对收到的签名解密。这样接收方就得到了两个哈希值，如果两个哈希值是一样的，则认为收到的签名是有效的。

DSS签名也是利用一个哈希函数产生消息的一个哈希值，哈希值连同一随机数k一起作为签名函数的输入，签名函数还需使用发方的秘密钥SK~A~和供所有用户一起使用的一组参数，这一组参数称为全局公开钥PK~G~。签名函数的两个输出s和r就构成了消息的签名(s,r)。接收方收到消息后再产生出消息的哈希值，将哈希值与收到的签名一起输入验证函数，验证函数还需输入全局公开钥PK~G~和发送方的公开钥PK~A~。验证函数的输出，如果与收到的签名成分r相等则验证了签名是有效的。

### 数字签名算法DSA

![image-20231030155919619](assets/image-20231030155919619.png)
![image-20231030155932680](assets/image-20231030155932680.png)
![image-20231030155941586](assets/image-20231030155941586.png)

## RSA签名体制

![image-20231030173117015](assets/image-20231030173117015.png)

## 基于离散对数的签名体制

### ElGamal签名体制

![image-20231030145524541](assets/image-20231030145524541.png)
![image-20231030145533282](assets/image-20231030145533282.png)
![image-20231030173249927](assets/image-20231030173249927.png)

### Schnorr签名体制

![image-20231030154144084](assets/image-20231030154144084.png)

## Guillou-Quisquater签名体制

![image-20231115215624416](assets/image-20231115215624416.png)
![image-20231115215639481](assets/image-20231115215639481.png)


## 认证协议

### 相互认证

保证实时性常用方法：时间戳、询问-应答

其中时间戳法不能用于面向连接的应用程序。

询问-应答方式不适合于无连接的应用过程。

通信双方建立共享密钥时可采用单钥加密体制和公钥加密体制

#### 单钥加密体制

![image-20231031144059067](assets/image-20231031144059067.png)
![image-20231031144108799](assets/image-20231031144108799.png)
![image-20231031144125859](assets/image-20231031144125859.png)
![image-20231031144150885](assets/image-20231031144150885.png)
![image-20231031144201775](assets/image-20231031144201775.png)
![image-20231031144210378](assets/image-20231031144210378.png)

#### 公钥加密体制

![image-20231031145433421](assets/image-20231031145433421.png)
![image-20231031145443784](assets/image-20231031145443784.png)
![image-20231031145454598](assets/image-20231031145454598.png)

### 单向认证

#### 单钥加密 

![image-20231031151318951](assets/image-20231031151318951.png)

#### 公钥加密

![image-20231031151333043](assets/image-20231031151333043.png)
![image-20231031151338727](assets/image-20231031151338727.png)

# 密钥分配和用户认证

认证方法：

- 用户个人知道的某事：例子包括密钥、个人验证码，预先安排的一系列问题的答案。
- 用户个人拥有的某种东西：例子包括密钥、电子钥匙卡、智能卡、物理钥匙。这种类型的身份验证器称为**令牌**
- 用户个人的某种东西（不变的生物特征）：包括指纹识别、视网膜识别、人脸识别等例子
- 用户个人的某种特别属性（后天生物特征）：包括声音模式识别、手写特征识别、打字节奏识别。

## 基于对称加密的密钥分配

对于对称加密，加密双方必须共享同一密钥

对于A、B双方有下列选择：

1. A能够选定密钥并通过物理方法传递给B
2. 第三方可以选定密钥并通过物理方法传递给A和B
3. 如果A和B不久之前使用过一个密钥，一方能够把使用旧密钥加密的新密钥传递给另一方。
4. 如果A和B各自有一个到达第三方C的加密链路，C能够再加密链路上传递密钥给A和B。

对于4，需要用到两种类型的密钥：

- 会话密钥：当两个端系统（主机、终端等等）希望通信，他们建立一条逻辑连接(如，虚电路)。再逻辑连接持续过程中，所有用户数据都使用一个一次性的会话密钥加密。再会话或连接结束时，会话密钥被销毁。
- 永久密钥：永久密钥在实体之间用于分发会话密钥。

对于4，需要一个密钥分发中心（KDC）。

### 集中式密钥分配

![image-20231031163758198](assets/image-20231031163758198.png)

### 分布式密钥分配过程

Diffe-Hellman密钥交换算法同步密钥过程

## Kerberos

Kerberos是一种认证服务。

Kerberos要解决的问题是：假设在一个开放的分布式环境中，工作站的用户希望访问分布在网络各处的服务器上的服务。希望服务器能够将访问权限限制在授权用户范围内，并且能够认证服务请求。在这个环境中，一个工作站无法准确判断它的终端用户以及请求的服务是否合法。特别是以下三种威胁：

1. 用户可能进入一个特定的工作站，并假装成其他用户操作该工作站。
2. 用户可能改变一个工作站的网络地址，从该机上发送伪造的请求。
3. 用户可能监听信息或者使用重放攻击，从而获得服务或者破坏整行操作。

利用集中的认证服务器来实现用户对服务器的认证和服务器对用户的认证。

Kerberos仅依赖于对称加密体制。

### Kerberos版本4

利用**DES**来提供认证服务

认证服务器（AS），它知道所有用户的口令，并把他们存储在集中式数据库中。此外，AS与每个服务器之间共享一个独立密钥。这些密钥已经从物理途径或其他安全途径进行了分发。

票据授权服务器（TGS）

Ticket：票据，可重用

Authenticator：认证符，只能使用一次，而且有效期非常短

票据并不证明任何人的身份，它只是安全分发密钥的一种方法。正是认证符证实了客户端的身份。

![IMG_20231031_195930](assets/IMG_20231031_195930-1698753923704-3.jpg)

![IMG_20231031_195936](assets/IMG_20231031_195936.jpg)
![IMG_20231031_195947](assets/IMG_20231031_195947.jpg)

### Kerberos域和多重Kerberos

一个提供全套服务的Kerberos环境包括一台Kerberos服务器、若干客户端和若干应用服务器。这个环境有如下要求：

1. Kerberos服务器的数据库中必须存有所有参与用户的ID和经过散列函数处理的口令。所有用户都要在Kerberos服务器上注册。
2. Kerberos服务器必须和每个服务器共享一个秘密密钥。所有的服务器都要在Kerberos上注册。

这种环境被称为Kerberos域。对于域的概念可以做如下解释。一个Kerberos域是共享同一个Kerberos数据库的一组受控节点。Kerberos数据库驻存于Kerberos主计算机系统中，它应该被放在一个物理上安全的房间中。一个只读的Kerberos数据库副本也可能驻存于其它的Kerberos计算机系统中。但是，所有对数据库的更改必须在主计算机系统中进行。改变或访问Kerberos数据库的内容需要Kerberos主口令。一个相关的概念是Kerberos主体。Kerberos主体是对Kerberos系统已知的服务或用户。每个Kerberos主体由其主体名标识。主体名由三部分组成：一个服务或用户名、一个实例名和一个域名。

在不同监管组织下的用户端/服务器网通常组建为不同的域。这样，让一个监管组织下的用户和服务器在其他地方的Kerberos服务器上注册是不现实的，或者是不符合监管策略的。然而，一个域中的用户可能需要访问其他域中的服务器，而且一些服务器也愿意为其他域的用户提供服务，只要它们是被认证过的。

### Kerberos版本5

版本4的环境不足：

1. 加密系统依赖性：版本4使用DES。在版本5中，密文被标记上加密类型标识，这使得可以使用任何类型的加密技术。加密密钥被标记上类型和长度，这就允许可以在不同的算法中使用相同的密钥，也允许在一个给定的算法中具有不同的规定。
2. 互联网协议依赖性：版本4需要使用互联网协议（IP）地址。其他类型的地址（比如ISO网络地址）不受支持。版本5的网络地址被标记上类型和长度，使得任何类型的网络地址都可以使用。
3. 消息字节排序：在版本4中，消息的发送方采用一种自己选择的字节排序，并对消息进行标注，以表明最低地址中的最低有效字节或最低有效地址中的最高有效字节。这种技术是可行的，但是它不符合已经形成的惯例。在版本5中，所有的消息结构都使用抽象语法表示法（ASN.1）和基本编码规则（BER），这两个标准提供了清晰的字节排序。
4. 票据有效期：版本4中的有效期由一个8比特的值来编码，并以5分钟为一个基本单位。这样，可以表示的最长有效期为2^8^*5=1280分钟，即21个小时多一点。这对某些应用来说是不够用的（比如一个在整个运行过程中需要合法Kerberos证书的运行时间很长的仿真）。在版本5中，票据有明确的开始时间和结束时间，这使得票据可以有任意的有效期。
5. 认证转发：版本4不允许将发给一个客户端的证书转发给其他主机，并由其他客户端使用。而这种功能可以使得一个客户端访问一台服务器，并让那个服务器以客户端的名义访问另一台服务器。例如，一个客户端访问一个打印机服务器，然后打印机服务器使用客户端的名义访问文件服务器中该客户端的文件。版本5提供了这种功能。
6. 域间认证：在版本4，如前所述，N个域中的互操作需要N^2^阶的Kerberos-Kerberos关系。版本5支持一种需要较少关系的方法。

版本4的技术缺陷：

1. 双重加密：向客户端提供的票据都经过双重加密，一次是被目标服务器的秘密密钥加密，另一次是被客户端所知道的秘密密钥加密。第二次加密是不必要的，这回造成计算上的浪费。
2. PCBC加密：版本4中的加密使用一种非标准的DES加密模式，这种模式为传密码分组链接（PCBC）。这种模式被证明是易受包含交换密码块的攻击方法攻击的。使用PCBC模式是想提供完整性检查作为加密操作的一部分。版本5提供了明确的完整性机制，这样就可以使用标准的CBC模式来加密。特别地，在进行CBC模式加密之前，将把一个校验和或散列码附加在消息中。
3. 会话密钥：每个票据都会包含一个会话密钥，它被客户端用来加密送给与票据相关联的服务的认证符。另外，会话密钥可能在后来，由客户端和服务器用来保护会话中传送的消息。但是，由于同一个票据可能被重用来获得一个特定服务器上的服务，这就存在攻击者重放先前与客户端或与服务器的会话的风险。在版本5中，客户端和服务器可以协商得到子会话密钥，子会话密钥只在那次连接中使用。客户端新的访问将会导致使用新的子会话密钥。
4. 口令攻击：两个版本都容易受口令攻击。由AS发给客户端得消息包括用基于客户端口令得密钥加密过的内容。攻击者可以截获这个消息，并试图用不同得口令解密它。如果试验解密的结果具有适当的形式，则攻击者旧发现了客户端口令，并且以后可以用其从Kerberos服务器取得认证证书。在版本5中的确提供了一种称为预认证的机制，这使得口令攻击更加困难，但它不能杜绝这种攻击。

![image-20231031210709146](assets/image-20231031210709146.png)
![image-20231031210722463](assets/image-20231031210722463.png)
![image-20231031210906337](assets/image-20231031210906337.png)
![image-20231031210921916](assets/image-20231031210921916.png)
![image-20231031211237095](assets/image-20231031211237095.png)



## 基于非对称加密的密钥分配

公开密钥加密算法密钥分发原则如下

1. 成对生成加密密钥和解密密钥

   加密密钥和解密密钥是一一对应的，用加密密钥加密的密文只能通过对应的解密密钥解密。因此，需要成对生成加密密钥和解密密钥。

2. 公告加密密钥、保密解密密钥。

   所有需要向指定接收者传输密文的发送者，可以用同一个加密密钥对明文进行加密运算。如果只有该接收者知道解密密钥，则只有该接收者能够解密所有发送者发送的密文。因此加密密钥可以通过有公信力的媒介公告，解密密钥必须只有密文接收者知道。

3. 需要证明密文接收者与加密密钥之间的关系。

   接收者A为了能够解密发送者发送给接收者B的密文，生成一对密钥PKA和SKA，并将加密密钥PKA作为接收者B的加密密钥予以公告。当发送者需要向接收者B传输密文时，错误地用PKA对明文进行加密运算。由于只有接收者A知道加密密钥PKA对应地解密密钥SKA，因此，接收者A可以解密发送者用PKA加密地密文。因此，为了防止某个接收者通过冒充其他接收者公告加密密钥地情况，加密密钥与密文接收者之间的绑定关系必须得到有公信力的权威机构的证明。

### 公钥证书

公钥证书由公钥加上公钥所有者的用户ID以及可信的第三方签名的整个数据块组成。

通常第三方就是用户团体所信任的**认证中心（CA）**,如政府机构或金融机构。用户可通过安全渠道把用户的公钥提交给这个CA，获取证书。然后用户就可以发布这个证书。任何需要该用户公钥的人都可以获取这个证书，并且通过所附的可信签名验证其有效性。

![image-20231031173234033](assets/image-20231031173234033.png)
人们广泛接受的公钥证书格式是X.509标准。其应用于大多数的网络安全设施，包括IP安全、安全套接字层（SSL)、安全电子交易（SET)和S/MIME。

### 基于公钥密码的秘密密钥分发

![image-20231031211918898](assets/image-20231031211918898.png)

### X.509证书

ITU-T推荐标准X.509是X.500推荐标准系列的一部分，X.500系列推荐标准定义了一套目录服务。所谓目录服务，实际上是指用于维护用户信息数据库的一个或一组分布式服务器。这些信息包括从用户名到网络地址的映射关系，以及其他关于用户的属性和信息。

X.509定义了一个使用X.500目录向其用户提供认证服务器的框架。该目录可以作为公钥证书存储库。每个证书都包括用户的公钥，并由一个可信任的认证中心用私钥签名。除此之外，X.509定义了另一个基于使用公钥证书的认证协议。

X.509基于公钥加密体制和数字签名的使用。这个标准并没有强制使用某个特定的数字签名算法，也没有规定特点的散列函数。

X.509方案的核心是与每个用户相关联的公钥证书。这些用户证书是由可信任的认证中心（CA）创建的，并由CA或用户放在目录中。目录服务器本身不负责公钥的产生和认证功能；它置为用户获取证书提供一个容易访问的场所。

![606d4d7d31057847f3228bf4ed7ffa9b](assets/606d4d7d31057847f3228bf4ed7ffa9b.jpeg)
![image-20231031213416370](assets/image-20231031213416370.png)
![image-20231031213435549](assets/image-20231031213435549.png)

![9c1ac71c0315a467f118ae84f332889f](assets/9c1ac71c0315a467f118ae84f332889f.jpeg)
![image-20231031214745054](assets/image-20231031214745054.png)
![image-20231031214830318](assets/image-20231031214830318.png)
![image-20231031214847575](assets/image-20231031214847575.png)

### X.509版本3

版本2没有满足以下要求

![02ab0d90aa11549482dcf49d6f93ce4a](assets/02ab0d90aa11549482dcf49d6f93ce4a.jpeg)

![image-20231101163658122](assets/image-20231101163658122.png)
![image-20231101164024111](assets/image-20231101164024111.png)

## 两种密钥体制的结合

![image-20231031165755184](assets/image-20231031165755184.png)

## 公钥基础设施（PKI）

公钥基础设施（PKI）：定义为基于非对称密码体制的用来生成、管理、存储、分配和撤销数字证书的一套硬件、软件、人员、策略和过程。

目标是使安全、方便和高效获取公钥成功的可能。

### PKIX架构模型

![IMG_20231101_164418](assets/IMG_20231101_164418.jpg)

- 端实体：一个用来表示终端用户、设备(比如服务器和路由器)或者任何其他的可以在公钥证书的主体域被确定身份的实体的通用术语。端实体一般采用和/或支持与PKI相关的服务。
- 认证中心(CA)：证书的发放者，通常也是撤销证书列表(CRL)的发放者。他还可能支持很多管理功能，虽然这些一般是由一个或多个注册中心代理。
- 注册中心(RA)：一个可选的部分，它承担很多从CA处继承的管理功能。经常将RA与端实体注册过程关联起来，但是也可以协助许多其他领域的工作。
- CRL发放者：一个可选的部分，它可以代理CA发布CRL
- 存储库：一个用来表示存储证书和CRL以使证书和CRL可以被端实体检索的任何方法的通用术语。

### PKIX管理功能

- 注册：这是一个过程，用户通过该过程在CA向其发放证书（一个或几个）之前，先让CA知道自己（直接或通过RA）。注册开始了一个PKI中的登记过程。注册通常包括一些离线或在线的步骤来相互认证。一般来说，为将来认证使用的一个和多个共享秘密密钥被发放给端实体。
- 初始化：在客户端可以安全 工作之前，需要安装密钥资料，这些密钥资料与存储在基础设施其他地方的密钥具有一定的关系。例如，客户端需要被安全地初始化，这需要使用公钥以及其他可信CA（一个或多个）担保的、将被用于验证证书路径的信息。
- 认证：这是一个过程，这个过程中，CA为一个用户的公钥发放一个证书，并将该证书返回给用户的客户端系统和/或将次证书存放在一个储存库中。
- 密钥对恢复：密钥对可用来支持数字签名的产生和验证，或者可用来支持加密和解密，或者两者都支持。如果一个密钥使用来加密和解密的，那么当不再能以通常的方式访问密钥资料时，提供一种机制来恢复解密密钥就是非常重要的，否则，就不可能恢复加密的数据。不能访问解密密钥可能由以下情况导致：忘记口令/PIN码、磁盘驱动损坏、硬件标记损坏等。密钥对恢复功能允许端实体从一个被授权的密钥备份设施（通常是给端实体发放证书的CA）处恢复它们的加密/解密密钥对。
- 密钥对更新：所有密钥对都需要定期更新（例如用一个新的密钥对代替），并且发放新证书。当证书过期或证书被撤销时，就需要更新。
- 撤销申请：一个经过授权的人告诉CA发生了一个异常情况，需要撤销证书。撤销证书的原因包括私钥泄露，合作方变化和名称改变。
- 交叉认证：两个CA相互交换用于建立交叉证书信息。一个交叉证书是一个CA给另一个CA发放的证书，证书中包含一个CA用于发放证书的签名密钥。

### PKIX管理协议

证书管理协议（CMP）

证书管理消息（CMC）

# 传输层安全

Web安全需求

![IMG_20231101_171405](assets/IMG_20231101_171405.jpg)

提供Web安全的一种方法是使用IPSec，另一种更一般的解决方案是仅在TCP上实现安全。

![image-20231101172027387](assets/image-20231101172027387.png)

## 安全协议

功能：

1. 双向身份验证

   基于共享密钥身份鉴别和基于证书身份鉴别

2. 数据加密

3. 数据完整性检测

4. 防重放攻击机制

   一是发送端为每一个不同的报文设置不同的序号，接收端丢弃序号重复的报文。

   二是接收端设置序号窗口，接收端只有接收到序号属于序号窗口的报文时，才处理该报文，否则丢弃该报文。



## 传输层安全（TLS）

**传输层安全(TLS)**是广泛使用的一种安全服务；
TLS是一种Internet标准，它是从称为**安全套接字层(SSL)**的商业协议发展而来的。

TLS是一种通用服务，是依赖TCP实现的一组协议。

### TLS体系结构

TLS使用TCP提供一种可靠的端对端的安全服务。

TLS不是单个协议，它由两层协议组成。

<img src="assets/image-20231101172913280.png" alt="image-20231101172913280" style="zoom:50%;" />

**<u>TSL记录协议</u>**对各种更高层协议提供基本的安全服务。尤其是，超文本传输协议（HTTP）是为Web客户端/服务器的交互提供传输服务的协议，它可以在TLS的顶层允许。

TSL中定义的三个较高层协议分别是：握手协议、修改密码规格协议、报警协议。这些协议规范用来管理TLS交换。

心跳协议

**TLS连接**：连接是一种能够提供合适服务类型（按照OSI分层模型定义）的传输。对TLS来说，这种连接是点对点的关系而且都是短暂的。每一条连接都与一个会话相关联。

**TLS会话**：TLS会话是客户与服务器之间的一种关联。会话是通过握手协议来创建的。所有会话都定义了密码安全参数集合，这些参数可以在多个安全连接之间共享。会话通常用来减少每次连接建立安全参数的昂贵协商费用。

任何一对实体（例如客户和服务器上的HTTP应用）之间都可以有多个安全连接。理论上也允许一对实体之间同时有多个会话存在，但实际上并非如此。实际上还有**若干个状态与每个会话相关联**。一旦建立起一个会话，对于读和写(即接收和发送)就存在一个当前操作状态。此外，在握手协议中，还会创建读挂起和写挂起状态。当握手协议结束后，挂起的状态又回到当前状态。

会话状态由下列参数定义(定义引自TLS 规范文件):

- **会话标识符**：由服务器产生的用于标识活动或可恢复的会话状态的一个任意字节序列。
- **对等实体证书**：对等实体的X.509v3 证书。会话状态的这一元素可以为空。
- **压缩方法**：加密前用于压缩数据的算法。
- **密码规格**：包括大块数据加密算法 (例如空算法、AES 算法等)规格和用于计算MAC的散列算法(如MD5或 SHA-1 算法等)规格。它还定义了一些密码属性，例如散列值长度等。
- **主密钥**：客户端和服务器共享的 48 字节的会话密钥
- **可恢复性**：表明会话是否可被用于初始化新连接的标志

连接状态由下列参数定义:

- **服务器和客户端随机数**：由服务器和客户端为每个连接选定的字节串。
- **服务器写 MAC 密钥**：服务器发送数据时用于计算 MAC 值的密钥
- **客户端写 MAC密钥**：客户端发送数据时用于计算 MAC 值的密钥
- **服务器写密钥**：服务器用于加密数据、客户端用于解密数据的加密密钥。
- **客户端写密钥**：客户端用于加密数据、服务器用于解密数据的对称加密密钥。
- **初始化向量**：在 密码分组链接（CBC）模式中，需要为每个密钥配置一个初始化向量 (IV)。最初的IV 值由 TLS 的握手协议初始化。之后，每个记录的最后一个密码块被保存，以作为后续记录的 IV。
- **序列号**：建立连接的各方为每条连接发送和接收的消息维护单独的序列号。当一方发送或接收改变密码规格的消息时，相应的序列号应置零。序列号的值不能超过 2^64^-1。

### TLS记录协议

TLS 记录协议为 TLS 连接提供如下两种服务：

- 机密性：握手协议定义一个可以用于加密 TLS 载荷的传统加密共享密钥
- 消息完整性：握手协议还定义一个用于产生消息认证码(MAC)的共享密钥

记录协议要传输应用消息时，先将数据分段成一些可操作的块，然后选择压缩或不压缩数据，再生成 MAC、加密、添加头并将最后的结果作为一个 TCP 分组送出。对接收到的数据，首先解密，然后做完整性验证、解压缩重组，最后把数据递送到更高层用户
![image-20231103094322004](assets/image-20231103094322004.png)

TLS 运行的第一步是**分段**。把每个上层消息分割为**不大于 214字节的块**。然后选择**压缩或不压缩**。**压缩必须是无损的并且增加长度不能超过 1024 字节。**在 TLSv2中，没有规定压缩算法，所以默认的压缩算法为空算法。

接下来的处理步骤是在压缩数据的基础上计算**消息认证码**。TLS使用RFC 2104中定义的HMAC算法。
![image-20231103094607627](assets/image-20231103094607627.png)
![image-20231103094652784](assets/image-20231103094652784.png)
MAC 计算涵盖了所有的字段，再加上 TLSCompressed.version，这是正在使用的协议版本。

之后，对压缩后的消息连同增加的MAC 使用**对称加密算法**进行加密。加密造成的块长度增量不会超过 1024 字节，所以块的总长度不会超过 2^14^+2048 字节。允许使用下面这些对称加密算法:
![image-20231103094805082](assets/image-20231103094805082.png)
对流密码算法，压缩后的消息与 MAC 码一起被直接加密。值得注意的是 MAC 码是在加密前计算得到的。计算所得的 MAC 码连同明文或压缩后的明文一同被加密。

对分组密码，可以在加密之前在 MAC 之后添加填充。填充是以多个填充字节的形式后跟填充长度的单字节指示。填充可以是总数中的任何数量的结果，其长度是密码的块长度的倍数，最大可到 255 字节。例如，如果密码的块长度是 16 字节 (例如 AES)或者如果某明文(或压缩后的明文)加上 MAC 再加上填充的长度是 79 字节，填充长度可以是 1、17、33 等，最大为 161 字节。如果填充长度为 161字节，总长度为 79 字节+161 字节=240字节。可变填充长度可用于阻止基于分析交换消息长度的攻击。

TLS记录协议处理过程的最后一步是添加一个由下列域组成的TLS头:

- 内容类型(8比特):用于处理封装分段的高层协议。
- 主版本号 (8比特):表明应用的TLS 协议的主版本号。对于 TLSv3.0，该值为3。
- 副版本号(8比特):表明应用的 TLS协议的从版本号。对于TLSv3.0，该值为0。
- 压缩后的长度 (8 比特):以字节为单位的明文块(如果使用了压缩，则为压缩后的明文块)长度。最大值为 2^14^+2048。

内容类型被定义为**修改密码规格、报警、握手和应用数据** 4种。前3 种是对 TLS特定的协议，后面再进行讨论。值得注意的是，在各种应用(例如，HTTP)中使用 TLS 没有什么限制，它们提供的数据内容对 TLS 来说是不透明的

图6.4 给出了TLS 记录协议的格式。

<img src="assets/image-20231103095258011.png" alt="image-20231103095258011" style="zoom:50%;" />

![image-20231103110955194](assets/image-20231103110955194.png)



### 修改密码规格协议

修改密码规格协议是应用TLS记录协议的4个TLS规格协议之一，也是最简单的一个协议。本协议只包含一条消息，由一个值为1 的字节组成。这条消息的唯一功能是使得挂起状态改变为当前状态，用于更新此连接使用的密码套件。
![image-20231103100420829](assets/image-20231103100420829.png)

### 警报协议

![image-20231103110927446](assets/image-20231103110927446.png)

警报协议用于将与 TLS 相关的警报传达给对等实体。与使用 TLS 的其他应用一样,报消息也要按照当前状态的规格进行压缩和加密操作。

这一协议过程中的每一条消息都由**两个字节**组成。其中**第一个字节**可以取值为**警告(1)**或**致命(2)**以表示消息的**严重程度**。**如果严重程度为致命，TLS 将立即结束当前连接。**虽然该会话中的其他连接还可以继续进行，但是本次会话不允许建立新的连接。**第二个字节**包括一种用于指明具体警告的编码。下面列出致命警告的内容(由TLS规范定义):

- 非预期消息：接收到不恰当的消息。
- MAC记录出错：接收到不正确的MAC码
- 解压缩失败：解压缩函数接收到不恰当的输入(例如，不能解压缩或解压缩后的数据大于允许的最大长度)。
- 握手失败：发送方在可选范围内不能协商出一组可接受的安全参数
- 不合法参数：握手消息中的域超出范围或与其他域不一致。
- 解密失败：以无效方式解密的密文，或者它不是块长度的偶数倍或其填充值，如果选中，则不正确。
- 记录溢出：收到的 TLS，其长度超过 2^14^+2048 字节的有效载荷(密文)，或解密为长度大于 2^14^+2048 字节的密文
- 未知 CA:收到了有效的证书链或部分链，但未接受证书，因为无法找到 CA 证书。或无法与已知的可信 CA匹配。
- 拒绝访问:收到有效证书，但在应用访问控制时，发送方决定不继续进行协商
- 解码错误:无法解码消息，因为字段超出其指定范围或消息长库不正确，
- 出口限制:检测到不符合关键长度出口限制的谈判。
- 协议版本:客户端尝试协商的协议版本已被识别但不受支持条消
- 安全性不足:当协商失败时，返回一个不是握手失败的信息，因为服务器要求的密码比客户端支持的密码更安全。
- 内部错误:与对等方无关的内部错误或协议的正确性使其无法继续
- 结束通知:通报接收方，发送方在本次连接上将不再发送任何消息。连接双方中的方在关闭连接之前都应该给对方发送这样一条消息。
- 没有证书:如果没有合适的证书可用时，发送这条消息作为对证书请求者的回应。
- 证书不可用:接收到的证书不可用 (例如包含的签名无法通过验证)。
- 不支持的证书:不支持接收到的证书类型。
- 证书作废:证书已被签发者吊销。
- 证书过期:证书已过期。
- 未知证书:处理证书过程中引起的其他未知问题，导致该证书无法被系统识别和接受。
- 解密错误:握手加密操作失败，包括无法验证签名，解密密钥交换，验证已完成的消息。
- 用户取消:由于与协议故障无关的某些原因，此握手被取消。
- 不重新谈判:由客户端响应“hello”请求，或服务器在初始握手后响应客户端“hello”而发送。这些消息中的任何一个通常都会导致重新谈判，但此警报表示发送方无法重新谈判。此消息始终是一个警告。

### 握手协议

![image-20231103110911626](assets/image-20231103110911626.png)

TLS 最复杂的部分是握手协议。**这一协议允许客户端和服务器相互认证，并协商加密和 MAC 算法，以及用于保护数据使用的密钥通过 TLS 记录传送。握手协议在任何应用数据被传输之前使用。**

握手协议由客户端和服务器之间的一系列消息交换组成。所有这些都如图 6.5(c)所示。每一条消息都包括三个域：

- 类型(1字节)：表示预定义的 10 种消息类型之一。表 6.2 列出定义的消息类型。
- 长度 (3 字节)：以字节为单位的消息长度。
- 内容(>0字节)：与本条消息相关的参数。它们由表 6.2 列出。

![image-20231103101503602](assets/image-20231103101503602.png)

图6.6 说明了为建立客户端和服务器之间的逻辑连接需要进行的初始交换。这些交换可分为 4 个阶段。
![image-20231103101528076](assets/image-20231103101528076.png)
<img src="assets/image-20231103110456690.png" alt="image-20231103110456690" style="zoom:50%;" />

#### 第一阶段

阶段一用于双方对压缩算法、加密算法、MAC算法及TLS协议版本达成一致。

客户C在客户Hello消息中按优先顺序列出客户C支持的算法列表及TLS版本，服务器V从客户C支持的算法列表中按优先顺序选择一种自己支持的算法作文双方约定的算法，在双方支持的TLS版本中选择较低的TLS版本作为双方约定的TLS版本，并通过服务器hello消息将双方约定的算法、TLS版本会送给客户C。

**第一阶段：客户端发起建立连接请求。**这一阶段主要是发起逻辑连接并建立与之关联的安全能力。交换首先由客户端通过发送下列**客户端请求（client_hello）消息**启动。

- 版本:客户端的TLS 最高版本。
- 随机数:由客户端产生的随机序列，由 32 比特时间截以及安全随机数生成器产生的 28 字节随机数组成。这些数没有任何意义，主要用于密钥交换过程中防止重放攻击。
- 会话ID:可变长度的会话标识符。非零值表示客户端希望更新现有连接的参数，或为该会话创建一条新连接。零值表示客户端希望在新会话上建立一条新连接。
- 密码套件:按优先级的降序排列的、客户端支持的密码算法列表。列表中的每一行(即每一个密码套件)同时定义了密钥交换算法和密码规格。这些我们接下来讨论。
- 压缩方法:客户端支持的压缩方法列表。

发送完客户端请求(client hello) 消息后，客户端将等待**服务器响应(server hello)消息**，该消息所包含的参数与客户端请求 (client hello) 消息包含的参数相同。同时服务器响应(server hello)消息遵循以下的惯例。版本域包含客户端支持的较低版本和服务器支持的最高版本。服务器产生一个独立于客户端随机域的新随机数域。如果客户端会话ID 域的值非零，那么服务器应采用相同的取值。否则，服务器的会话 ID 域将包括一个新会话值密码套件域将包括服务器从客户端提供的可选方案中选定的唯一一组密码套件。压缩域包括服务器从客户端建议中选定的压缩方法。

密码套件参数的第一项内容是密钥交换方法(如传统加密密钥和 MAC 交换方法)。协议支持下列密钥交换方法。

- RSA：用接收方的 RSA 公加密的密钥。这里必须要有一个接收方的可用公钥证书。
- 固定 Diffie-Hellman: Diffie-Hellman密钥交换过程，其中服务器证书中包含的公钥参数由认证机构(Certification uthority，CA)签发。也就是说，公钥证书包含 Diffie-Hellman 公钥参数。客户端可以通过证书提供其公钥参数(如果需要对客户端认证)，也可以通过密钥交换消息提供其公钥参数。使用固定的公钥参数和Diffie-Hellman 算法进行计算将导致双方产生固定密钥。
- 暂态 Diffe-Hellman：这种技术用于创建暂态(临时或一次性)密钥。在这种情况下，Difie-Hellman公钥通过使用发送方的RSA私钥或DSS密钥的方式被交换和签名。接收方可以用相应的公钥验证签名。证书用于认证公钥。这种方式似乎是三种Diffe-Hellman密交换方式中最安全的一种，因为它最终将获得一个临时的、被认证的密钥。
- 匿名Diffie-Hellman (Anonymous Difie-Hellman)：使用基本 Difie-Hellman 密钥交换方案，且不进行认证。也就是说，双方发送自己的 Difie-Hellman 参数给对方且不进行认证。这种方法容易受到“中间人攻击法”的攻击，其中攻击者与双方都进行匿名 Diffie-Hellman 密钥交换。
- Fortezza:这种技术专为 Fortezza 方案而定义。

紧随密钥交换方法定义之后的是密码规格，它包括下面这些域:

- 密码算法:可以是前面提到的算法中的任何一种:RC4、RC2、DES、3DES、DES40、IDEA 或 Fortezza。
- MAC 算法:MDS 和 SHA-1。
- 密码类型:流密码或分组密码
- 可否出口:可以或不可以。
- 散列长度:0、16(用于MD5)或20(用于SHA-1)字节。
- 密钥材料:字节序列(其中包含用于产生写密钥的数据)。
- IV 大小:密码分组连接 (CBC) 加密模式中初始向量的大小。

#### 第二阶段

![a0c8a93f342095ead516eec79226ca08](assets/a0c8a93f342095ead516eec79226ca08.jpeg)

**第二阶段:服务器认证和密钥交换。**如果需要认证，则这一阶段的开始以服务器发送其证书为标志。发送的消息包括一个 X.509 证书或一个 X509 证书链。证书消息对于除匿名Diffie-Hellman 密钥交换方法外的其他密钥交换方法都是必需的。值得注意的是如果使用固定匿名 Diffie-Hellman 密交换方法，这一证书消息执行和服务器的密钥交换消息一样的功能，因为它包含了服务器的 Diffie-Hellman 公钥参数。

之后，如果有必要，将发送一个服务器密钥交换(server_key_exchange)消息。在下列两种情况下无须发送该消息:

- 服务器已发送包含固定 Diffie-Hellman 参数的证书
- 使用了 RSA 密交换方法。

下列情况需要服务器密钥交换消息:

- 匿名 Diffie-Hellman:消息由两个全局 Diffie- Hellman 密值 (一个素数和它的一个本原根)以及一个服务器公钥 (见图 10.1)组成。
- 暂态 Diffie-Hellman: 消息内容由三个 Diffie-Hellman 参数和一个对这些参数的签名组成。
- RSA 密钥交换(这种情况服务器使用 RSA,但是使用一个仅用于签名的 RSA 密钥)：一般来说，客户端不能简单地发送一个用服务器公钥加密的密钥。相反，服务器必须产生一组临时 RSA 公钥/私钥对并使用服务器密钥交换消息发送其中的公钥。消息由两个临时 RSA公钥(幂指数和模数，见图3.11)以及对这些参数的签名组成。

下面是有关签名的一些具体细节。通常，得到消息的散列值之后使用发送方的私钥对它加密就可得到签名。这里，散列定义如下:

![image-20231103103646056](assets/image-20231103103646056.png)
所以，散列值不仅涉及 Diffie-Hellman 或RSA 参数，还涉及当前的初始连接消息，这样可以抵抗重放攻击和误传。对于DSS 签名，散列值的计算使用了 SHA-1 算法。对于RSA签名，同时使用MD5算法和 SHA-1 算法计算两个散列值，并对它们的串接(36字节)伸用服务器的私钥进行加密。

接下来，如果服务器使用的不是匿名 Diffie-Hellman 算法，则服务器可以向客户端请求证书。certificate_request (证书请求)消息包括两个参数:certificate_type (证书类型)和certificate_authorities (证书机构)。证书类型指出了公钥算法及其用法:

- RSA:仅限于签名。
- DSS:仅限于签名。
- 固定 Diffie-Hellman 中的 RSA: 在这种情况下签名只用来进行认证，该认证是通过发送一个由 RSA 签名的证书来完成的。
- 固定 Diffie-Hellman 中的 DSS:同样仅用于认证。

证书请求消息中的第二个参数是一个可接受的认证机构名称列表。

第二阶段中的最后一条消息 (也是始终需要存在的消息之一) 是服务器结束(server_done)消息。该消息由服务器发出并示意服务器的 hello 及相关消息已经结束。该消息没有参数，发送完这个消息后，服务器要等待客户端的响应。

#### 第三阶段

![image-20231103114237182](assets/image-20231103114237182.png)
![image-20231103114344383](assets/image-20231103114344383.png)
![image-20231103114358702](assets/image-20231103114358702.png)
![image-20231103114449423](assets/image-20231103114449423.png)

**第三阶段：客户端认证和密钥交换。**接收到服务器结束消息后，如果需要，客户端应该验证服务器提供的证书是否有效，同时还要检查服务器请求 (server_hello) 参数是否是可接受的。如果所有这些条件均满足，那么客户端将返回一条或更多消息给服务器。

如果服务器已请求证书，则以客户端发送一条证书 (certificate) 消息为这一阶段的开始。如果没有合适的证书可用，那么客户端发送一个无证书警报 (no_certificate_alert)。

接下来是客户端密钥交换 (client_key_exchange) 消息。该消息必须在这一阶段发送消息内容由下列的密钥交换类型决定：

- RSA：客户端产生一个48字节的预备主密(pre-master_secret)，并用从服务器证书中得到的公钥或者用从服务器密钥交换(server_key_exchange)消息中得到的RSA临时密钥进行加密。如何利用它计算主密钥将会在后面进一步解释
- 暂态或匿名Diffe-Hellman：发送客户端的 Diffie-Hellman 公钥参数
- 固定Diffie-Hellman：以证书消息的形式发送客户端的 Diffie-Hellman 公钥参数，该消息内容为空。

最后，在这一阶段，客户端可以发送证书验证 (certificate_verify)消息，以便对客户端证书进行显式验证。仅当客户端证书具有签名功能(也就是说，除包含固定 Diffie-Hellman参数外的所有证书)时才会发送该消息。这个消息是对一个散列码的签名，该散列码基于前面的消息，定义如下:
![image-20231103104422695](assets/image-20231103104422695.png)
其中握手消息(handshake_message)是客户端启动客户端请求时发送或接收到的所有握手协议消息，但不包括客户端请求消息本身。如果用户的私钥是 DSS，则它将用于加密 SHA-1的散列值。如果用户的私钥是 RSA，则它将用来加密 MD5 和 SHA-1 散列值的串接。这两
种情况的目的都是为了验证客户端证书的私钥确实为客户端所有。如果他人误用了客户端的证书，将无法发送该消息。

#### 第四阶段

![image-20231103114556892](assets/image-20231103114556892.png)

**第四阶段:完成。**这一阶段完成安全连接的建立。客户端发送一个修改密码规格(change cipher spec)消息，并把挂起的密码规格复制到当前密码规格中。值得注意的是，该消息不是握手协议的一部分，而是使用修改密码规格协议发送的。客户端在新算法、新密钥和新密钥值下立即发送结束 (fmished)消息。结束消息用于验证密钥交换和认证过程是否成功。结束消息是两个散列码的串接:
![image-20231103104551430](assets/image-20231103104551430.png)
其中，结束标签 (finished_label)对客户端来说是“client finished”字符串，对服务器来说是“server finished”字符串。

作为对客户发送的这两条消息的响应，服务器发送自己的修改密码规格消息，把未定的密码规格转变为当前的密码规格并发送其结束消息。到此为止握手过程已经完成，客片端与服务器可以开始交换应用层数据。

### 密码计算

本节关注以下两个问题:一是**通过密钥交换创建一个共享主密钥**，二是**从共享主密钥中产生密码参数**。

**主密钥的创建。**共享主密钥是通过安全密钥交换方式为本次会话创建的一个一次性 48字节(384 比特)的值。创建过程分两步完成。第一步，交换**预备主密钥**。第二步，双方计算**主密钥**。

对**预备主密钥的交换**，有下面两种情况:

- RSA:客户端产生一个 48 字节的预备主密钥，并使用服务器的 RSA 公加密，然后将其发送给服务器。服务器使用自己的私钥解密以得到 pre master secret (预备主密钥)。
- Diffie-Hellman:服务器和客户端各自产生一个 Diffie-Hellman 公钥值。交换之后双方再分别做 Diffie-Hellman 计算来创建共享的预备主密钥。

现在，客户和服务器都按照下面方法计算主密钥：

![image-20231103105051296](assets/image-20231103105051296.png)

其中，ClientHello.random 和 ServerHello.random 是在初始 hello 消息中交换的两个随机数。

这个算法一直要执行到 48 字节的伪随机输出都产生完为止。密钥块的计算（MAC密钥、会话加密密钥和IV）定义如下：
![image-20231103105556722](assets/image-20231103105556722.png)
直至产生足够的输出为止。

密码参数产生。密码规格要求客户端写MAC值的密钥，服务器写MAC值密钥，客户端写密钥，服务器写密钥，客户端写初始向量IV，服务器写初始向量IV，这些都是按顺序由主密钥产生的。其方法是主密钥利用散列函数来产生安全字节序列，字节序列足够长以便生成所有需要的参数。

从主密钥中计算密钥材料的方法和从预备主密钥中计算主密钥的格式相同：
![image-20231103105745210](assets/image-20231103105745210.png)

该计算过程一直持续到产生足够长的输出。该算法结构的结果相当于一个**伪随机函数**。主密钥可以认为是伪随机函数的种子值。客户端和服务器的随机数可以认为是增加密码分析复杂度的“加盐”。

**伪随机函数**  TLS 使用一个称为 PRF 的伪随机函数来扩展密钥以得到密钥产生和验证中的各种密钥块。采用伪随机函数的目的是使用相对较小的共享密钥值，生成较长的数据块，防止对散列函数和MAC的攻击。PRF 基于下面的数据扩展函数 (见图6.7):
![image-20231103110141333](assets/image-20231103110141333.png)
数据扩展函数使用以MD5或SHA-1 作为基本散列函数的HMAC算法。从上面的定义中可以看出，P_hash 可以根据迭代的次数来产生所需的数据量。例如，如果要使用P_SHA-1立生64 字节的数据，则需要迭代 4 次，先产生 80字节的数据，然后将最后 16 字节丢弃而如果采用P_MD5，同样需要迭代 4 次，生成恰好 64 字节的数据。值得注意的是，每迭代一次将涉及两次 HMAC 计算，其中的每一次计算又涉及两次散列算法的计算。

为了使PRF 做到尽可能安全，同一种情况下可以使用两个不同的散列函数。如果这两个函数中有一个是安全的，那么其安全性就可以得到保证。这种情况下 PRF 的定义如下:
![image-20231103110236120](assets/image-20231103110236120.png)
PRF 包含三个输入，分别是密钥值、标识符和种子。通过这些参数可以产生一个任意长的输出。

### 心跳协议

在计算机网络环境中，心跳是由硬件或软件产生的周期性信号，以指示正常操作或同步系统的其他部分。心跳协议通常用于监视协议实体的可用性。在 TLS 的特定情况下,2012 年在 RFC 6250(传输层安全 (TLS)和数据报传输层安全 (DTLS)心跳扩展)中定义了心跳协议。

心跳协议运行在 TLS 记录协议之上，并且由两种消息类型组成:心跳请求 (heartbeat request)和心跳响应(heartbeat response)。心跳协议的使用是在握手协议的第一阶段中建立的(图6.6)。每一个 peer 都指示是否支持心跳。若是支持心跳，则 peer 指示它是否可以接收心跳请求信息并且以心跳响应信息作为响应，或者只是可以接收心跳请求信息。

一条心跳请求信息可以在任何时间发出。**任何时候只要接收一条请求信息，都应该及时地应答一条相应的心跳响应信息来对其进行响应。心跳请求信息包括负载长度、负载和填充字段。**负载是长度在 16 字节到 64 千字节之间的随机内容。**相应的心跳响应信息必须包括接收到的负载的精确复制。**填充字段也是随机内容。填充字段使得发送方可以执行一个路径 MTU(最大传输单元)发现操作，通过发送不断增加填充字段的请求直到没有应答为止，因为路径中某个主机无法处理这些信息。

**心跳协议有两个目的。首先，它可以向发送方保证接收方是存活的，即使底层 TCP 连接上已经一段时间没有活动了。其次，心跳协议在空闲时期会在连接中产生活动，以避免被不兼容空闲连接的防火墙关闭。**

心跳协议中也设计了**负载交换**，以支持它在 TLS 的无连接版本即数据报传输层安全中的使用。因为无连接服务受制于丢失的数据包，负载使得请求方可以将应答信息和请求信息进行匹配。

### SSL/TLS攻击

我们可以将攻击分成四个一般类别:

1. **攻击握手协议**:早在 1998 年，一种基于利用格式化和 RSA 加密电路的实施的方法就被提出来对握手协议进行攻击(BLEI98)。对策的实施又使这个攻击进行了改善调整使得其不仅可以阻止对策还可以加速攻击 (例如 BARD12)。
2. **攻击记录和应用数据协议**: 在这些协议当中发现了大量漏洞，因此需要打补丁以计算新的威胁。例如在2011 年研究员 Thai Duong和Juliano Rizzo提出了一个名为 BEASI(针对SSL/TLS 的浏览器开发)的概念，就把曾被看作只是理论上的漏洞变成了实际的攻[GOODI1]。BEAST利用一种被称为选择明文攻击的攻击。攻击者通过对一个已知密文相关明文进行猜测来发动攻击。研究者对成功发动攻击建立了一个实际的算法。后来的补丁可以阻止这种攻击。BEAST 的作者也是 2012CRIME(压缩率使信息很容易泄露)的创造者这种攻击使得攻击者在数据压缩和 TLS 一起使用的情况下，可以恢复网页 Cookie 的内容[GOOD12]。当被用于恢复密钥认证 Cookie 的内容时，攻击者可以在一个认证的网页会话中执行会话劫持。
3. 攻击 PKI:对一些攻击来说，检查 SSL/TLS 内容中或者其他地方的 X509 证书的合法性都是一个很重要的主题。比如，SSL/TLS 常用的库易受证书验证实施的影响。作者暴露了OpenSSL、GnuTLS、JSSE、ApacheHttpClient、Weberknecht、cURL、PHP、Python
   源代码和建立于这些产品的应用或者与这些产品一同建立的应用中的弱点。
4. 其他攻击:[MEYE13]列出了一些不符合前面任何一种攻击类型。其中一个例子就是在2011 年被德国黑客组织 The Hacker Choice 提出的攻击，这是一个 DoS 攻击KUMAIIJ这种攻击通过使用 SSL/TLS 握手请求压倒目标，在服务器上造成了沉重的处理负载。通过建立新的连接或者使用重协商来增加系统的负载。假设在握手期间主要的计算是由服务器完成，这种攻击在服务器上产生的系统负载多于在源设备上产生的，就导致了 DoS，服务器被迫不断重新计算随机数和密钥。

SSL/TLS 攻击和对策的历史进程也代表了其他网络协议进程。完美协议和完美实施策略永远也不可能实现。在威胁和对策当中持续不断地更替决定了网络协议的演变。

### TLSv1.3

最主要的目的是增强TLS的安全性。

相对于版本 1.2 来说有以下一些显著的改变:
![image-20231103111655760](assets/image-20231103111655760.png)

### HTTPS

基于 SSL/TLS的HTTP，HTTPS(HTTP 和SSL) 是指用 **HTTP 和TLS 的结合来实现网络浏览器和服务器之间的安全通信。**HTTPS 被融合到当今的网络浏览器中。它的应用依赖于网络服务器是否支持HTTPS 通信。例如，搜索引擎不支持HTTPS。

在 TCP 基础上建立 TLS 安全连接,经过 TLS安全连接实现对 Web 服务器的身份鉴别,浏览器和 Web 服器之间传输的 HTTP消息的保密性、完整性和源端鉴别。

![image-20231103112315999](assets/image-20231103112315999.png)

在一个浏览器用户看来,它们的主要区别表现在URL地址开始于 **https://**而不是 http://一个标准的HTTP 连接使用 80 端口。**当指定HTTPS 时，将使用443 端口。**

当使用 HTTPS时，通信的以下元素被加密:

- 要求文件的URL
- 文件的内容
- 浏览器表单的内容（由浏览器的使用者填写）
- 从浏览器发送道服务器和从服务器发送道浏览器的Cookie
- HTTP报头的内容

#### 连接初始化

对于HTTPS，用作 HTTP 的客户端的代理和用作 TLS 客户端的代理是一致的。用户在合适的端口向服务器发起一个连接，然后发送 TLS ClientHello，开始 TLS 信号交换。当 TLS信号交换完毕后，用户将发起第一次 HTTP 请求。所有 HTTP 数据都要以TLS 应用数据的形式发送。然后是包括保持连接在内的传统 HTTP 操作。

需要明确的是，一个HTTPS 连接中有三层不同的意思。在 HTTP 层面，一个 HTTP 用户通过向下一层发送一个连接请求来向服务器请求一个连接。通常，下一层是 TCP，但也可能是 TLS/TLS。在 TLS 层，在 TLS 用户和 TLS 服务器之间建立会话。**这个会话期可以在任何时间支持一个或多个连接。**正如我们所见到的那样，一个 TLS 连接请求的开始伴随着一个TCP连接的建立，该连接建立在 TCP 的客户端的实体和服务器之间。

#### 连接关闭

一个HTTP 用户或者服务器可以通过在HTTP 记录中加入“connection: close”的字样指示一个连接的关闭。这意味着该连接将会在该条记录传输之后关闭。

关闭一个 HTTPS 连接要求关闭 TLS 与其对应的远程终端之间的连接,这要求关闭潜在的 TCP 连接。在 TLS 层，关闭一个连接的适当做法是两端都是用 TLS 警报通信协议发出一个“close notify”警告。TLS 实例必须在关闭连接之前发起一个关闭警报的交换。在发出一个关闭警告后，一个 TLS 实例会关闭这个连接,而不会等待它的另一端发来关闭警告,这会导致一个“不完整的关闭”。如果一个用户这么做了，可能是为了之后再次使用该会话。这只有在这个应用层知道(通常是通过检查 HTTP 消息边界它接收了所有它关心的数据之后才可以完成。

HTTP客户端也必须能够应对这种情况,就是潜在的TCP连接在没有事先的“close notif"警告和“connection: close”指示的情况下被终止。这种情况可能是由于一个服务器的程序错误或者一个通信错误导致 TCP 连接的中断。

#### HTTPS安全传输 HTTP 消息过程

![image-20231103112620278](assets/image-20231103112620278.png)

![image-20231103112650450](assets/image-20231103112650450.png)
![image-20231103112738291](assets/image-20231103112738291.png)

# IPSec

## IPSec的应用

IPSec是网际层实现IP分组端到端安全传输的机制，由一组安全协议组成。**鉴别首部（AH）**、**封装安全净荷（ESP）**是其中两个协议，AH和ESP均实现IP分组源端鉴别和防重放攻击等功能，二者的差别是，AH只实现数据完整性检测，ESP实现数据加密和完整性检测。

为了是实现安全关联的动态建立过程，设计了**Internet密钥交换协议（IKE）**，IKE用于完成安全关联两端之间的双向身份鉴别过程和安全关联相关安全参数的协商过程。

IPSec提供了在LAN、专用和公用WAN以及互联网中安全通信的性能。它的用途包括：

- 通过互联网安全分支机构接入：一个公司可以在互联网或者公用WAN上建立一个安全的**虚拟专用网络**。这使得强烈依赖互联网的交易称为可能，并减少了对专用网络的需求，节约了成本和网络管理的费用。
- 通过互联网进行安全远程访问：这使得使用IPSec协议的终端用户能通过在本地向互联网服务提供商(ISP)提出申请，以获得对公司网络的安全访问。这样就降低了出差员工和远程通信者的费用。
- 与合作者建立企业间联网和企业内联网接入：可以使用IPSec实现和其他组织的安全通信，确保认证和保密，并提供密钥交换机制。
- 加强电子商务安全性：虽然一些Web和电子商务应用建立在内置的安全协议上，但是使用IPSec可以提高安全性。

IPSec网络设备一般对进入WAN的所有流量进行加密、压缩，对来自WAN的所有流量进行解密和解压缩。

<img src="assets/image-20231101200920881.png" alt="image-20231101200920881" style="zoom: 50%;" />

### IPSec的好处

- 当在路由器和防火墙中使用IPSec时，它对通过其边界的所有通信流提供了强安全性。公司或者工作组内部的通信不会引起与安全相关的开销。
- 防火墙内的IPSec能在所有的外部流量必须使用IP时组织旁路，因为防火墙是从互联网进入组织内部的唯一通道。
- IPSec位于传输层（TCP、UDP）之下，所以对所有应用都是透明的。因此当防火墙或者路由器使用IPSec时，没有必要对用户系统和服务器系统的软件做任何改变。即使终端系统中使用IPSec，上层软件和应用也不会受到影响。
- IPSec可以对终端用户透明的。不需要对用户进行安全机制的培训，如分发基于每个用户的密钥资料，或在用户离开组织时撤销密钥资料。
- 若有必要，IPSec能给个人用户提供安全性。这对网外员工非常有用，它对在敏感的应用领域中组建一个安全虚拟子网络也是有用的。

### 路由应用中的IPSec

IPSec在互联网的路由结构中扮演着非常重要的角色。IPSec可确保：

- 路由器广播（新的路由器公告它的存在）来自授权的路由器。
- 邻居广播（路由器试图建立或维护与其他路由区域中路由器的邻居关系）来自授权的路由器。
- 重定向报文，它来自被发送给初始包的路由器
- 路由更新未被伪造

没有上述安全措施，攻击者可能会中断通信或者转发某些流。路由协议（比如开放最短路径优先OSPF）应该运行在由IPSec定义的路由器间安全关联的最上层。

### IPSec服务

IPSec包括三种功能：认证、机密性、密钥管理

如下服务：

- 访问控制
- 无连接完整性
- 数据源认证
- 拒绝重放包
- 保密性（加密）
- 受限制的流量保密性

## IP安全策略、安全关联

IP安全策略本质上由两个交互的数据库，**安全关联数据库（SAD）**和**安全策略数据库（SPD）**确定。

<img src="assets/image-20231101203253987.png" alt="image-20231101203253987" style="zoom:50%;" />

### 安全关联(SA)

定义：为了实现数据发送者至接收者的安全传输，需要建立发送者与接收者之间的关联，这种以实现源端鉴别、数据加密和完整性检测为目的的关联称为**安全关联**

安全关联是**单向的**，用于确定发送者至接收者传输方向的安全传输过程所使用的加密算法和加密密钥、消息鉴别码(MAC)算法、MAC密钥等

如果某对发送者和接收者之间需要安全传输数据，必须先建立发送者至接收者的安全关联。

一个安全关联由如下三个参数唯一确定：

1. **安全参数索引（SPI）**：赋给此SA的一个仅在本地有意义的比特串。**此SPI由AH和ESP报头携带**，使得接收系统能选择合适的SA（接收到的数据包将在此SA下处理）
2. **IP目的地址**：目前仅允许使用单播地址，这是SA的**目的端点地址**，可以是终端用户系统或者防火墙、路由器这样的网络系统。
3. **安全协议标识**：它标识关联是一个AH安全关联还是一个ESP安全关联

具有相同接收者的安全关联（目的IP地址相同的安全关联）需要分配不同的SPI。

**安全协议标识符** 指定该安全关联使用的安全协议，目前已经定义的安全协议有只对数据进行完整性检测的鉴别首部(AH)和对数据进行加密和完整性检测的封装安全净荷(ESP)协议。

<img src="assets/image-20231101184916272.png" alt="image-20231101184916272" style="zoom:50%;" />

### 建立数据与安全关联之间的绑定

发送者如果需要安全传输数据给接收者，必须先确定用于安全传输数据的安全关联，同一对发送者和接收者之间可以建立多个安全关联，因此，发送者不能简单通过数据的接收者建立安全关联。数据的目的地和安全关联的目的地可以不同。为此，发送者需要通过定义**安全策略数据库（SPD）**来判别数据传输所使用的安全策略。

SPD的目的是将数据分类，然后对不同的数据施加不同的安全策略，这些安全策略可以是丢弃、使用IPSec和不使用IPSec。如果某类数据的安全策略是使用IPSec，需要将该类数据绑定到某个安全关联，如果该安全关联不存在，则需要动态建立安全关联。

分类数据的依据是数据的源和目的IP地址、数据所使用传输层协议、传输层源和目的端口号、传输数据使用的安全协议、数据所要求的服务类型等。

### **安全关联数据库(SAD)**

所有安全关联相关参数集合构成**安全关联数据库(SAD)**，它定义了与每个SA相关的参数。

每一个安全关联需要定义以下参数：

- 安全参数索引（SPI）：由SA接收方选定的一个32比特数值，用于唯一标识该SA。在一个外联型SA的SAD实体中，该SPI用于构造包的AH或ESP的头。在一个内联型SA实体中，该SPI把流量映射到相应的SA。
- 序号：32位长度、作为AH或ESP首部中序号字段值，用于防止重放攻击。在安全关联存在期间，不允许出现相同序号的AH或ESP报文。
- 序号计数器溢出：这是一个标识，它用来表明序列号计数器的溢出是否生成一个可审计事件并阻止在此SA上继续传输数据包。
- 防重放攻击窗口：用于确定接收到的AH或ESP报文是否是重放报文
- AH信息：消息鉴别码(MAC)算法，MAC密钥，MAC密钥寿命，及其他用于AH的参数。
- ESP信息：加密算法和加密密钥，MAC算法和MAC密钥，初始值，密钥寿命，及其他用于ESP的参数。
- 安全关联寿命：可以是一段用于确定安全关联存在时间的时间间隔，也可以是安全关联允许发送的字节数。一旦安全关联经过了安全关联寿命定义的时间间隔，或是发送了安全关联寿命允许发送的字节数，将立即终止该安全关联。
- IPSec协议模式：传输模式、隧道模式、通配符模式
- 路径最大传送单元（MTU）：不用分段可以在安全关联绑定的发送端和接收端之间传输的最大分组长度。

### 安全策略数据库（SPD）

IP流量与特定的SA关联（不需要IPSec保护时没有SA）的方法在名义上是安全策略数据库（SPD）。

在最简单的情况下，一个SPD应该包括入口，每个入口都定义了一个IP流量子集并未该流量指向一个SA。
在更复杂的情况下，多个入口可以与一个SA相关，或者多个SA与一个SPD入口相关。

每个SPD入口由一个IP集和上层协议的域值定义，称为**选择器**。实际上，这些选择器用于过滤输出流，这是为了将流量映射到一个特定的SA。每个IP包的输出过程遵循下面的一般顺序：

1. 将包中相应域的值（选择器）与SPD比较，找到一个匹配的SPD入口，它可能指向零个或者多个SA。
2. 若该包存在SA，则为改包确定SA以及与其关联的SPI
3. 执行所需的IPSec处理（如AH或ESP处理）

SPD入口由以下选择器决定：

- 远程IP地址：可以是单一的IP地址、一个枚举列表、一个地址范围或一个通配符（掩码）地址。后两者需要支持多个目的地系统共享一个SA（例如，位于防火墙之后）。
- 本地IP地址：可以是单一的IP地址、一个枚举列表、一个地址范围或一个通配符（掩码）地址。后两者需要支持多个目的地系统共享一个SA（例如，位于防火墙之后）。
- 下层协议：该IP协议头（IPv4、IPv6、IPv6扩展）包括一个域（对IPv4就是协议，对IPv6或其扩展是下一个头），该域规定了IP层上的协议操作。这是一个单独的协议号，可以是任何数，但是对IPv6不透明。如果使用AH或ESP，则该协议头必须立即置于包中该AH或ESP头的前面。
- 名称：来自操作系统的用户标识。在IP层或者更上层报头中它不是一个域，但若IPSec和用户处于同一操作系统，此域就是可获得的。
- 本地和远程端口：可以是单个TCP或UDP端口值、端口枚举列表或一个通配符端口。

![image-20231101210307394](assets/image-20231101210307394.png)
![image-20231101210318565](assets/image-20231101210318565.png)
![image-20231101210330808](assets/image-20231101210330808.png)
SPD中的实体需要是自解释的。例如，UDP端口500是IKE的特定端口。为了IKE交换而在当地主机和远程主机之间的任何通信要通过IPSec进程。

### IP通信进程

IPSec实在报文到报文的基础上执行的。

当IPSec执行时，发往外部的IP包在传送前经过IPSec逻辑的处理，而发往内部的IP包在接收之后并且发送报文内容到更高层之前（例如TCP或UDP）经过IPSec逻辑的处理。

**出站报文**：

<img src="assets/image-20231101211056564.png" alt="image-20231101211056564" style="zoom:50%;" />

来自高层的数据块，传输到IP层并形成IP包，报文包含IP头和IP数据体，然后发生以下步骤：

1. IPSec查询SPD对该报文寻找匹配。
2. 如果没有匹配，报文被丢弃并生成错误信息。
3. 如果发现匹配，则进一步的处理由SPD的第一个匹配接口决定。如果对该报文的策略是丢弃，则该报文被丢弃。如果策略是通过，则没有进一步的IPSec处理；报文传向网络以便发送。
4. 如果策略是保护，则查询SAD来寻找匹配接口。如果没有发现接口，则引入IKE生成具有合适密钥的SA，并在SA上产生接口。
5. SA上的匹配接口决定报文的进一步处理。对报文加密或认证，或者二者都被执行，并且既可以使用传输模式，也可以使用隧道模式。报文传向网络以便发送。

**入站报文**

<img src="assets/image-20231101211628717.png" alt="image-20231101211628717" style="zoom:50%;" />

一个到来的IP包引起IPSec进程，并发生以下步骤：

1. 通过检测IP协议域（IPv4）或者下一个头域（IPv6），IPSec决定这是一个不安全的IP包还是一个有ESP或者AH头/尾的报文
2. 如果报文不安全，IPSec查询SPD为该报文寻找匹配。如果第一个匹配接口的策略是通过，则IP头经过处理后被剥离，而IP数据体传输到更高层（如TCP）。如果第一个匹配接口的策略是保护或者丢弃，或者没有匹配接口，则报文被丢弃。
3. 对应安全报文，IPSec查询SAD。如果没有匹配，报文被丢弃。否则，IPSec使用合理的ESP或者AH进程。然后IP头经过处理后被剥离，而IP数据体传输到更高层。



## 传输模式和隧道模式

### 传输模式

传输模式用于保证数据端到端安全传输，并对数据源端进行鉴别，在这种模式下，IPSec所保护的数据就是作为IP分组的净荷的上层协议数据，如TCP、UDP报文和其他基于IP的上层协议报文。安全关联建立在数据源端和目的端之间。

<img src="assets/image-20231101190733957.png" alt="image-20231101190733957" style="zoom:33%;" />

### 隧道模式

安全关联的两端是隧道的两端。

在这种模式下，连接源端和目的端的内部网络被一个公共网络分隔，由于内部网络使用本地IP地址，而公共网络只能路由以全球IP地址为目的IP地址的IP分组，因此，直接以源端IP地址为源IP地址、目的端IP地址为目的IP地址的IP分组不能由公共网络正确地从路由器R1路由到路由器R2，路由器R1为了将源端至目的端IP分组经过公共网络传输给路由器R2，**将源端至目的端地IP分组作为净荷封装在以路由器R1的全球IP地址为源IP地址，路由器R2的全球IP地址为目的IP地址的IP分组中**，这种将整个IP分组作为另一个IP分组的净荷的封装方式就是隧道格式，在这种情况下，安全关联的两端就是隧道的两端，对于源端至目的端传输方向，**安全关联的发送端是路由器R1，接收端是路由器R2。**

![image-20231101202749325](assets/image-20231101202749325.png)



### 防重放攻击过程

新建立源端至目的端的安全关联式，序号初始值为0。源端发送AH或ESP报文时，先将序号增1，然后增1后的序号作为AH或ESP报文的序号字段值。

在安全关联寿命内，不允许出现相同的序号，因此，目的端只要接收到序号重复的AH或ESP报文，确定是重复接收到的AH或ESP报文，予以丢弃。

由于AH或ESP报文经过IP网络传输后，不是按序到达目的端，因此，序号小的AH或ESP报文后于序号大的AH或ESP报文到达目的端是正常的，但AH或ESP报文经过IP网络传输的时延抖动有一个范围，如果某个AH或ESP报文的传输时延和其他AH或ESP报文经过IP网络传输的时延的差值超出这个范围，可以认为该AH和ESP报文被黑客延迟了一段时间。

防重放攻击窗口就用于定义正常的时延抖动范围。假定防重放攻击窗口值为W，目的端正确接收到的AH或ESP报文中最大序号值为N，则序号值为N-W+1 ~ N 的AH或ESP报文属于虽然传输时延大于序号为N的AH或ESP报文，但传输时延仍在正常的时延抖动范围内的AH或ESP报文，目的端正常接收这些AH或ESP报文。

目的端每接收到一个AH或ESP报文，执行操作：

1. 如果报文序号小于N-W+1，或者该序号对于的报文已经正确接收，丢弃该报文。
2. 如果报文序号在窗口范围内，且未接收过该序号对应的报文已经正确接收，接收该报文并将该序号对应的标志改为以正确接收该序号对应的报文。
3. 如果报文序号大于N，假定为L（L>N），将窗口改为L-W+1 ~ L，并将序号L对应的标志改为已正确接收该序号对应的报文。

![image-20231101193527378](assets/image-20231101193527378.png)

## 鉴别首部AH

### AH报文格式

传输模式，在IP首部和净荷之间插入鉴别首部AH

在隧道模式下，整个IP分组作为隧道格式的净荷，在外层IP首部和净荷之间插入鉴别首部AH。

<img src="assets/image-20231101193808622.png" alt="image-20231101193808622" style="zoom:50%;" />

**鉴别首部（AH）格式**

<img src="assets/image-20231101193923868.png" alt="image-20231101193923868" style="zoom:50%;" />

- **下一个首部**：指出净荷的协议类型，封装成传输模式的AH报文后，**<u>IP首部中的协议字段值为51</u>**，表明是AH报文，IP首部中原用于指明净荷协议类型的协议字段值作为AH中的**下一个首部字段值**。封装成隧道模式的AH报文后，外层IP首部中的协议字段值为51，表明是AH报文，AH中的下一个首部是表明净荷是隧道格式的协议字段值。
- 鉴别首部长度：**以32位为单位给出AH的总长**，实际的鉴别首部长度=AH总长-2，一般情况下，鉴别数据为96位，三个32位字，因此AH的总长为6个32位字，使得鉴别首部字段值位4。
- 安全索引参数（SPI）：接收端将其和AH报文的目的IP地址和IP首部（隧道模式下的外层IP首部）中IPSec协议类型一起用于确定AH所属的安全关联。
- 序号：用于防重放攻击
- 鉴别数据：消息鉴别码(MAC)，用于鉴别源端身份和实现数据完整性检测。

鉴别数据的计算可以采用以下两种MAC算法：①HMAC-MD-96；②HMAC-SHA-1-96。这两种算法表明，采用基于密钥的报文摘要计算过程时，报文摘要中截取96位作为鉴别数据。

建立安全关联时，源端和目的端必须约定所采用的散列消息鉴别码（HMAC）算法和MAC密钥。

计算鉴别数据时覆盖AH报文下述字段：

1. IP首部（隧道模式下时是外层IP首部）中传输过程中不需改变的字段值，如源和目的IP地址等。
2. AH中除鉴别数据以为的其他字段值，如SPI、序号等
3. AH报文中的净荷，如果是隧道模式，净荷是包括内层IP首部的整个IP分组。

目的端假别成功的前提是：①源端和目的端采用相同的HMAC算法和MAC密钥；②计算鉴别数据时所覆盖的字段值在传输过程中未被篡改。

<img src="assets/image-20231101195738964.png" alt="image-20231101195738964" style="zoom:50%;" />

### AH应用实例

![image-20231101195826401](assets/image-20231101195826401.png)

## 封装安全载荷ESP

ESP可以提供机密性、数据源认证、中断连接后的完整性、一次抗重放攻击服务（一种部分序列完整性形式）和（受限的）流量机密性。所提供的服务集合依赖于建立安全关联（SA）时和在一个网络拓扑中的位置。

ESP支持很多加密和认证算法，包括如GCM这样的既认证有加密算法。

### ESP格式

<img src="assets/image-20231101214200742.png" alt="image-20231101214200742" style="zoom: 67%;" />

ESP包的顶层格式。它包括以下域：

- 安全索引参数（SPI）：32比特，标识一个安全关联
- 序列号：32比特，一个递增的计数值，提供了抗重放功能
- 载荷数据：长度可变，这是被加密保护的传输层分段（传输模式）或者IP包（隧道模式）
- 填充域：0~255字节
- 填充长度：8比特，表明此域前面一个域中填充数据的长度。
- 邻接报头：8比特，通过标识载荷中的第一个报头来标识包含在载荷数据域中的数据类型（例如IPv6的扩展报头或TCP这样的上层协议）
- 完整性校验值：长度可变，一个可变长的域（必须位32比特的字长的整数倍），它包含ICV。ICV的计算参量位ESP包中除认证数据域外的其他部分。

当使用任何组合式算法时，该算法本身既能够返回解密的明文，又能够返回一个指示完整性校验通过或不通过的信息。对组合式算法，通常应该会在ESP包（当选择完整性校验时）最后出现的ICV值会被省略。当选择完整性校验且省略ICV值时，在载荷数据内设置一种域ICV等价的方法区验证包的完整性则成为组合式算法的职责。

在载荷中，可能会出现两个额外的域。一个是**初始值（IV）或随机数**，它在针对ESP的加密或认证加密算法要求出现时会出现。对另一个，如果是隧道模式，则IPSec的实现可能会在载荷数据之后，填充域之前，增加**流量机密性（TFC）填充**。

<img src="assets/image-20231101215231756.png" alt="image-20231101215231756" style="zoom:67%;" />

### 加密和认证算法

ESP服务加密载荷数据、填充域、填充长度和邻接报头域，如果用于加密载荷的算法需要使用密码同步数据，如初始向量(IV)，则这些数据可以在载荷数据域的开始处显示的传输。如果包括IV，它虽然被看成是密文的一部分，但不会被加密。

ICV域是可选的。仅当选择了完整性服务且该服务或者由一个单独的完整性算法提供，或者由用于ICV的组合式算法提供时，该域才会出现。ICV值是在加密完成后才被计算。这种处理顺序能使在对包解密前就可以对接收方的重放或伪造做出快速的检测与拒绝，从而可以潜在的降低拒绝服务攻击Dos的影响。它还对接收方对包的并行处理的可能性留有余地。也就是说，解密和完整性校验可以并行的处理。注意，由于ICV值未作加密保护，对ICV值的计算需要用带密钥的完整性算法。

### 填充

填充域由如下几个作用：

- 如果加密算法要求明文为某个数目字节的整数倍（如分块加密中要求明文是单块长度的整数倍），填充域用于把明文（包括载荷数据、填充、填充长度、邻接报头域）扩展到需要的长度
- ESP格式要求填充长度和邻接报头域为右对齐的32比特的字，同样，密文也是32比特整数倍，填充域用来保证这样的排列。
- 增加额外的填充能隐藏载荷的实际长度，从而提供部分流量的保密。

### 防重放攻击

在建立一个新的SA时，发送方把序号计数器的初始值设为0，每次在SA上发送一个包，则发送方增加计数器的值并把这个值存放到序列号域中。这样第一个被使用的值为1.如果要求抗重放（默认），则发送方不许循环计数（循环计数值到达（3^32^-1）后返回到0），否则，一个序列号会对应很多合法的包。如果到了（3^32^-1）这个极限，发送方就会终止这个给SA，用新的密钥协商生成新的SA。

IPSec认证文档规定接收方应该实现一个大小为W的窗口（W的默认值是64）.窗口的右端代表最大的序列号N，记录目前收到的合法包的最大序列号。序列号在（N-W+1）~ N的包已经被正确的接收（即被认证），并在窗口的相应位置上坐好标记。当接收到包时，内部的处理过程如下：

1. 如果接收到的包超过了窗口中而且是新包，则验证消息验证码（MAC）。若验证通过，就标记窗口中相应的位置。
2. 如果接收到的包超过了窗口的有边界而且是新包，则验证MAC。若验证通过，就让窗口前进以使得这个序列号成为窗口的右边界，并标记窗口中的相应位置。
3. 如果接收到的包超过了窗口的左边界或者没有通过验证，就丢掉这个包，这是一个可审计事件。

<img src="assets/image-20231102143407487.png" alt="image-20231102143407487" style="zoom:50%;" />

### 传输模式和隧道模式

在两个主机之间直接提供加密和认证(认证可选)。由传输模式的SA支持

<img src="assets/image-20231102143718956.png" alt="image-20231102143718956" style="zoom:50%;" />

使用隧道模式建立虚拟专用网络。由隧道模式的SA支持。
<img src="assets/image-20231102143805874.png" alt="image-20231102143805874" style="zoom:50%;" />

#### 传输模式ESP

传输模式ESP用于加密和认证(认证可选)IP携带的数据（如TCP分段）。当传输模式使用IPv4时，ESP报头被插在传输层报头前面的IP包中，ESP尾（填充、填充长度和邻接报头域）被放在IP包的后面。如果选择认证，**ESP认证数据域就被放在ESP尾部之后**，**整个传输层分段和ESP尾部一起被加密**，**认证覆盖了所有的密文和ESP报头。**

在IPv6的情况下，ESP被看成是端对端的载荷，也就是说，它不会被中间路由器检查或处理。因此ESP报头出现在IPv6基本报头、逐跳选项、路由选项和分段扩展报头之后。而目的可选拓展报头是出现在ESP报头之前还是之后是由语义来决定。**对于IPv6，加密将覆盖整个传输层分段、ESP尾部和目的可选扩展报头（如果目的可选扩展报头出现在ESP报头之后）**。**认证将覆盖密文和ESP报头。**

关于传输模式操作总结如下：

1. 在源端，将加密由ESP尾部和整个传输层分段组成的数据块，然后此块的密文区代其明文形成要传输的IP包。若是选择了认证，则加上认证。
2. 之后，将包路由到目的地。每个中间路由器都要检查和处理IP报头和任何明文形式的IP扩展报头，但是不需要检查密文。
3. 目的节点检查和处理IP报头和任何明文形式的IP扩展报头，然后基于ESP报头中的SPI，目的结点解密包的剩余部分，恢复明文形式的传输层分段。

传输模式操作作为使用它的任何应用提供了保密性，这样就不用在每个应用中实现保密性。同时这种模式的操作也当然是搞笑的，仅增加了少量的IP包的长度。此模式的一个弱点是对传输包进行流量分析是可能的。

#### 隧道模式

隧道模式ESP是用来加密整个IP包。

在这种模式下，ESP报头是包的前缀，所以包与ESP尾部被一同加密，该模式可用来组织流量分析。

由于 IP 报头包含了目的地址，还可能包含源路由指示以及逐跳信息，所以不可能简单地传输带有 ESP 报头前缀的加密过的IP 包。中间路由器不能处理这样的包。因此，使用能为路由提供足够信息却没有为流量分析提供信息的新IP 报头封装整个模块(ESP 报头、密
文和验证数据，如果它们存在) 是必要的。

**传输模式适合于保护支持 ESP 特性的主机之间的连接**
**隧道模式在包含防火墙或其他类型的用于保护可信内网不受外网侵害的安全网关的配置中是有用的。**

**隧道模式情况下,加密发生在外部主机和安全网关之间，或者是发生在两个安全网关之间。**这就减轻了网内主机的加密负担，并通过降低所需密钥数来简化密钥分发任务。另外，它阻止基于最终目的地址的流量分析。

考虑以下情况:外部主机希望与受防火墙保护的内部网络主机通信，ESP 在外部主机和防火墙中实现。从外部主机到内部主机的传输层分段将按照如下步骤传送：

1. 源端将产生一个以目的地内部主机作为目的地址的内部IP 包。这个包以ESP 报头为前缀，然后加密包和 ESP 尾部，并且可能添加认证数据。再用目的地址是防火墙地址的新IP报头(基本报头和可选的扩展，如路由和 IPv6 的逐跳信息)封装数据块，从而形成了外部的IP 包。
2. 将外部IP 包路由到目的地防火墙，每个中间路由器要检查和处理外部的IP 报头和任何外部IP 扩展报头，但不需要检查密文。
3. 目的地防火墙检查和处理 IP 报头和任何外部 IP 扩展报头。然后目的地节点利用ESP 报头里的 SPI对IP 包剩余的部分解密，恢复内部I 包的明文，这个包就可以在内部网络中传输。
4. 内部包在内部网络中经过零个或者多个路由器到达目的地主机

![image-20231102150127779](assets/image-20231102150127779.png)

<img src="assets/image-20231102150034450.png" alt="image-20231102150034450" style="zoom:50%;" />

<img src="assets/image-20231102150217598.png" alt="image-20231102150217598" style="zoom:50%;" />

### 安全关联组合

单个SA 能实现 AH 或者 ESP 协议，但是不能同时实现这两者。有时，特定的流量能调用由 AH 和 ESP 提供的服务。另外，特定的流量可能需要主机间的 IPSec 服务和安全网关(比如防火墙)间的独立服务。在这些情况下，同一个流量可能需要多个 SA 才能获得想要的 IPSec 服务。术语**<u>安全关联束</u>**指的是为提供特定的 IPSec 服务集所需的一个 SA 序列安全关联束中的 SA 可以在不同节点上终止，也可以在同一个节点上终止。

安全关联可以通过如下两种方式组合成安全关联束：

1. **传输邻接**：这种方法指在没有激活隧道的情况下，对一个包使用多个安全协议。这种组合 AH和 ESP 的方法仅考虑了单层组合，更多层次的嵌套不会带来收益，因为所有的处理都是在一个 IPSec 实例处执行的，这个实例就是(最终)目的地。
2. 隧道迭代:指通过 I 隧道应用多层安全协议。这种方法考虑了多层套，因为每个隧道都能在路径上的不同IPSec 节点处起始或终止。

可以组合使用这两种方法，例如，在主机之间使用传输 SA，在安全网关的路径上使用隧道SA。

#### 带认证选项的ESP

首先，用户对要保护的数据使用ESP，然后添加认证数据域，这又分为以下两种情况：

1. 传输模式ESP：被传送到主机的IP载荷使用了认证和加密，但是IP报头不受保护。
2. 隧道模式ESP：认证作用于被发送到外部IP目的地址（如防火墙）的整个IP包，并在目的地进行认证。整个内部IP包由专用机制保护，这是为了被传送到内部IP目的地。

在这两种情况下，认证作用于密文而不是明文。

#### 传输邻接

**在加密之后使用认证的另一种方法就是使用两个捆绑在一起的传输SA,内部是ESP SA，外部是 AH SA，在这种情况下，使用的 ESP 没有认证选项。(先加密后认证)**

由于内部 SA 是一个传输 SA,所以加密仅作用于 IP 载荷。最后得到由 P 报头(可能有 IPv6 扩展报头)和接在其后的 ESP组成的包。之后，使用传输模式下的 AH，以使认证能作用于 ESP 和除了可变域之外的源IP 报头(与扩展报头)。与仅使用带 ESP 选项的单个 ESP SA 相比，这种方法的**优点是认证能覆盖更多的域(包括源 IP 地址和目的IP 地址)，缺点是有两个 SA 的开销，而不是一个**

#### 传送-隧道束

在加密之前使用认证有几个优点：

1. 因为加密能保护认证数据，所以，中途截获数据并更改数据而不被发觉是不可能的。
2. 可能会希望在目的地存储带着报文的认证信息以便将来查阅。如果将认证信息应用于未加密的消息，则进行这样的处理更加方便,否则，要重新加密消息来验证认证信息。

在两个主机之间**先认证再加密**的一种方法是使用包括**内部 AH 的传输 SA 和外部 ESP的隧道 SA 的安全关联束**。此时，认证被作用于 IP 载荷和除了可变域之外的 IP 报头(包括扩展报头)，然后隧道模式 ESP 处理得到的 IP 包。结果是整个经过认证的内部包被加密，并增加了新的 IP 报头(和扩展报头)。

#### 安全关联的基本组合

![image-20231102151702562](assets/image-20231102151702562.png)
![image-20231102151724044](assets/image-20231102151724044.png)
![image-20231102151740320](assets/image-20231102151740320.png)

## Internet密钥交换协议 （IKE）

两种建立安全关联的机制：①静态安全关联建立机制 ②动态安全关联建立机制

动态安全关联建立机制根据安全传输数据的需要，通过协议建立发送端至接收端的安全关联，协商与安全关联相关的参数。

IKE就是一种动态建立安全关联并完成参数协商的协议。

如果没有找到匹配的安全关联，启动IKE，根据IP分组匹配的安全策略的要求，动态建立安全关联。

两个阶段：建立安全传输通道、建立安全关联
其中第一个阶段建立安全通道的过程也称为建立IKE安全关联的过程，第二个阶段建立安全关联的过程称为建立IPSe安全关联的过程。

### 因特网密钥交换

IPSec的密钥管理部分包括**密钥的确定和分发**。一**个典型的要求是两个应用之间的通信需要4个密钥：用于完整性和机密性的发送对和接受对。**

两种类型的密钥管理：

1. 手动类型：系统管理者为每个系统手动配置系统自己的密钥和其他通信系统的密钥，这对小的、相对静态的环境是可行的。
2. 自动类型：自动系统能够在需要时为SA创建密钥，并通过这种配置来使一个大型分布式系统中密钥的使用更加方便。

默认的IPSec自动类型密钥管理协议是ISAKMP/Oakley，它由以下几部分组成。

- Oakley密钥确定协议：基于Diffie-Hellman算法的密钥交换协议，但它提供额外的安全性，Oakley的通用性在于它没规定任何特殊的格式。
- 互联网安全关联和密钥管理协议（ISAKMP）：为互联网密钥管理提供了一个框架，并提供了特定的协议支持，包括格式和安全属性协商。

ISAKMP本身没有规定特定的密钥交换算法，而是由一组支持使用各种密钥交换算法的消息类型组成。Oakley是ISAKMP的最初版本中规定使用的特定密钥交换算法。

在IKEv2中不在使用术语Oakley和ISAKMP，并且IKEv1中对Oakley和ISAKMP使用相比较，有着明显的查查吧。显然，基本功能还是相同的。这一节介绍IKEv2。

### 密钥确定协议

IKE密钥确定是Diffie-Hellman密钥交换算法的细化。

Diffie-Hellman密钥交换算法优点：

- 仅在需要时生成密钥，而不需要长时间的存储密钥，从而增加了安全性。
- 交换仅需要全局参数达成一致，不需要其他预先存在的基础设施。

Diffie-Hellman密钥交换算法弱点：

- 它没有提供标识各方身份的任何信息。
- 易受中间人攻击。
- 算法是计算密集型的。易受拥塞攻击。

IKE密钥确定的设计保持了Diffie-Hellman的优点，而弥补了以上不足。

IKE密钥确定的特性：

1. 它运用了一种称为Cookie的机制来防止拥塞攻击。
2. 它允许双方协商得到一个组，在本质上，这就是详细列出Diffie-Hellman密钥交换的全局参数。
3. 它使用随机数来阻止重放攻击。
4. 它允许交换Diffiie-Hellman的公钥值
5. 它认证Diffie-Hellman交换，以此阻止中间人攻击。

Cookie交换要求各方在最初消息中发送一个伪随机数Cookie，此消息要得到对方的确认。此确认必须在Diffie-Hellman密钥交换的第一条消息中重复。如果源地址被伪造，那么攻击者就不会收到应答。这样，攻击者仅能让用户产生应答而不进行Diffie-Hellman计算。

ISAKMP规定Cookie的产生必须满足三个基本要求：

1. Cookie必须依赖于特定的通信方，这能防止攻击者得到一个正在使用真正的IP地址和UDP端口的Cookie，因此也就无法用该Cookie向目标主机发送大量的来自随机选取的IP地址和端口号的请求，以达到浪费主机资源的目的。
2. 除了发起实体意外的任何实体都不可能产生被它承认的Cookie。这就意味着发起实体在产生和验证Cookie时，要使用本地的秘密信息，并且，根据任何特定的Cookie都不能推断出该秘密信息。实现这个要求的目的在于发起实体不需要保存它发行的Cookie的副本，仅在必要时能验证收到的Cookie应答，所以降低了泄露的可能。
3. Cookie的产生和验证方法必须很快，以组织企图占用处理器资源的攻击。

推荐的创建Cookie的方法是根据IP的源地址、目的地址、UDP的源端口、目的地端口和本地产生的秘密值来进行快速散列运算（如MD5）。

IKE密钥确定支持使用不同的组进行Diffie-Hellman密钥交换。每个组都包括两个全局参数的定义和算法标识。当前规范包括如下组：

<img src="assets/image-20231102163028031.png" alt="image-20231102163028031" style="zoom:50%;" />
<img src="assets/image-20231102163112001.png" alt="image-20231102163112001" style="zoom: 67%;" />

IKE密钥确定使用随机数来防止重放攻击，每个随机数都是本地产生的伪随机数。它在应答中出现，并在交换的特定部分被加密以保护它的可用性。

IKE密钥确定可以使用三个不同的认证方法：

- 数字签名：用双方均可以得到的散列码进行签名的方法来认证交换，每一方都用自己的私钥加密散列值。散列值是使用重要的参数(如用户、随机数)生成的。
- 公钥加密：用发送方的私钥对参数 (如ID、随机数)加密来认证交换
- 对称密钥加密：使用其他方法传送密钥，并用该密钥对交换参数进行对称加密，从而实现对密钥交换过程的认证。



**IKEv2 交换**

IKEv2 协议的消息交换以配对形式出现。

前两对交换的消息称为**起始交换** (见图 9.11 (a))。交换的第一阶段中，双方交换有关密码算法的信息和连同随机数及Diffie-Hellman 值在内的其他他们愿意使用的安全参数。这轮交换的最终结果是他们建立了一个称为 IKE SA 的特别安全关联(见图 9.2)。该 SA 为通信方随后要在其上进行消息交换的安全通道定义参数。因此，随后的任何IKE 消息交换都受加密和消息认证保护。

在交换的第二阶段，通信双方相互认证和建立第一个IPSec SA，并将之存于 SADB 以便保护正常通信(亦即非 IKE)之用。因此就通常的应用，建立一个初次安全关联 SA 需要四类消息。

CHEATE CHILD_SA 交换可用于建立进一步保护流量的 SA。信息交换用于交换管理信息，IKEv2 错误信息和其他通知。![image-20231102164040018](assets/image-20231102164040018.png)

### 报头和载荷格式

<img src="assets/image-20231102164332738.png" alt="image-20231102164332738" style="zoom:50%;" />

IKE定义了建立、协商、修改和删除安全关联的程序和包的格式。作为安全关联建立的一部分，IKE定义了交换密钥生成和认证数据的载荷这些数据在和格式提供了独立于特定的密钥交换协议、加密算法和认证机制的统一框架。

#### IKE报头格式

IKE消息由一个IKE报头和其后的一个或多个载荷组成。实现必须在传输协议中支持UDP。

报头格式：

- 发起者SPI：64比特，一个由发起者选定的用于唯一标识IKE 安全关联（SA）的值。
- 响应者SPI：64比特，一个由相应者选定的用于唯一标识IKE SA的值
- 邻接载荷：8比特，指明消息中第一个载荷的类型
- 主版本：4比特，指明正在使用的IKE的主版本
- 从版本：4比特，指明正在使用的从版本，
- 交换类型：8比特，指明交换类型。
- 标志：8比特，指明这个IKE交换的特定的选项集。到目前为止定义了3个比特。发起者比特指明该包是否由发起者发送。版本比特指明传输者是否有能力使用一个比当前指明的版本号更高的一个主版本号。响应者比特指明该响应是否是对一个保护同样消息ID消息的响应。
- 消息ID：32比特，用于控制丢包的再传请求与响应的匹配
- 长度：32比特，以字节为单位的消息的总长度（报头及所有的载荷）

#### IKE载荷类型

所有的IKE 载荷都开始于相同的一般载荷报头(如图 9.12(b)所示)。

如果某个载荷是这个消息中的最后一个载荷，则邻接载荷域的值为零，否则，邻接载荷的类型就是邻接载荷域的值。

载荷长度域指明以学节为单位的载荷与一般载荷报头的长度和。

当发送方不能识别前一个载荷的邻接载荷的类型码时，发送方希望得到发送收据以便浏览该载荷，这时临界比特值取 0。当发送方不能识别该载荷类型，并且发送方希望得到该载荷收据以便拒绝该主体消息时，临界比特值设定为 1。

SA载荷用于开始建立一个 SA。该载荷有一个复杂的层次结构。该载荷可能包括多种提议。每个提议又可能包括多种协议。每个协议又会包括多种转换。每个转换又包含多个属性。这些情况在一个载荷内以子结构的方式说明如下:

- 提议：这一子结构包括一个提议号、一个协议ID(AH、ESP或IKE)、一个转换书指示器和一个转换子结构。如果一个提议中包括多于一个的协议时，则会有一个与提议数相同的并发提议子结构。
- 转换：不同的协议支持不同的转换类型。转换的原意是用来定义一个特别协议使用的密码算法的。
- 属性：每一个转换可能包括一些修改和完善转换规范的属性，如密钥长度。

![image-20231102172845373](assets/image-20231102172845373.png)

密钥交换载荷可用于各种密钥交换技术，包括Oakley、Diffie-Hellman和PGP使用的基于RSA的密钥交换。密钥交换数据域包含产生会话密钥所需要的数据，并独立于所使用的密钥交换算法。

标识载荷用于确认通信双方的身份，也可用来确认信息的真实性。典型的ID数据域包括IPv4或IPv6的地址

证书载荷传送公钥证书。证书编码域标明证书的类型或者证书相关的一些信息，可能包括如下部分：

- PKCS#7 包装的X.509证书
- PGP证书
- DNS签名密钥
- X.509证书——签名
- X.509证书——密钥交换
- kerberos令牌
- 证书撤销列表（CRL）
- 认证撤销列表（ARL）
- SPKI证书

在证书交换的任何时候，发送方都可能包含一个证书请求载荷来请求其他通信实体的证书。载荷可以列出多个可接受的证书类型和多个可接受认证中心（CA）。

认证载荷包括用于消息认证目的的数据。目前定义的认证方法有RSA数字签名、共享密钥消息完整性码和DSS数字签名。

随机数载荷包括用于交互的随机数据，它用来阻止重放攻击。

公告载荷包括与该SA或SA协商相关的错误或状态信息，下面列出已经定义的IKE公告信息。
![image-20231102190027558](assets/image-20231102190027558.png)

删除载荷指明一个或多个发送方从其数据库里删除的且不在有效的SA。

供应商ID载荷包含一个供应商定义的常数。该常数供应商用于标识和识别它们产品实现的远程实例。这种机制可以使一个供应商在保持向后兼容情况下实验新特性。

流量选择器载荷允许用户识别IPSec 服务器正在处理的数据包流。

被加密载荷包含其他加密形式的载荷。加密后的载荷格式类似于 ESP。它可能包含在加密算法要求下的初始向量IV 和认证需要的ICV。

配置载荷用于IKE 用户之间交换配置信息。

可扩展认证协议 (EAP) 载荷允许使用 EAP 对IKE SA 认证

### IKE相关配置

假定终端A要求与终端A通过HTTP访问Web服务器B相关的IP分组封装成AH报文。终端A制订一条安全策略，该条安全策略中分类IP分组的标准如下：

- 源IP地址=3.3.3.3/32
- 目的IP地址=7.7.7.7/32
- 目的端口号=80
- 协议类型=TCP

该条安全策略中对符合分类的IP分组实施的安全操作如下。

- 安全协议=AH
- MAC算法=HMAC-MD5-96

对于如图 6.14 所示的需要建立动态安全关联的发送端和接收端,终端 A和 Web 服务器均需完成以下与IKE 动态建立安全关联有关的配置
![image-20231102192546557](assets/image-20231102192546557.png)
IKE 动态建立安全关联过程分为两个阶段,第一个阶段是建立安全传输通道,第二个阶段是建立安全关联。建立安全传输通道的目的是可以安全传输为建立安全关联而相互交换的信息。相同发送端和接收端之间只需要建立一条安全传输通道，通过该安全传输通道可以建立多个安全关联。

第一阶段建立安全通道的过程也称为建立IKE 安全关联的过程，为了区分,把第二阶段建立安全关联的过程称为建立 IPSec 安全关联过程。

终端 A 和 Web 服务器 B之间建立安全传输通道前，需要相互鉴别对方身份，因此需要约定鉴别方式。为了安全传输为建立 IPSec 安全关联而相互交换的信息，建立安全传输通道时,需要约定加密算法和 MAC算法、加密密钥和 MAC 密等。建立IPSec 安全关联时,需要约定安全协议 AH、MAC算法 HMAC-MD5-96 和MAC 密等。

<img src="assets/image-20231102192747971.png" alt="image-20231102192747971" style="zoom:50%;" />

### IKE建立安全关联过程

![image-20231102192942554](assets/image-20231102192942554.png)
![image-20231102193001445](assets/image-20231102193001445.png)
![image-20231102193012184](assets/image-20231102193012184.png)




## 密码套件

![image-20231102191740050](assets/image-20231102191740050.png)
![image-20231102191757511](assets/image-20231102191757511.png)
![image-20231102191812950](assets/image-20231102191812950.png)
![image-20231102191825874](assets/image-20231102191825874.png)
