# 欧几里得算法（扩展的）

求最大公因数 求最大公倍数 求逆元

求最大公因数 最大公倍数 也可以分解素因子

# 同余定理P21

# 同余式

# 同余式求解P30

![image-20231018203255593](assets/image-20231018203255593.png)

![image-20231018203145380](assets/image-20231018203145380.png)

# 第一章

系统的保密性不依赖于对加密体制或算法的保密，而依赖于密钥

明文消息空间、密文消息空间、加密变换、解密变换、密钥空间

密码体制分类：单钥体制、公钥体制

单钥体制：流密码、分组密码。

对密码系统的攻击类型：

1. 唯密文攻击
2. 已知明文攻击
3. 选择明文攻击
4. 选择密文攻击

# 流密码

## 同步流密码

密钥流产生器、加密变换器

抗线性分析、抗统计分析

## 有限状态自动机

初始状态、序列（从左往右）、输出、状态转变，转移图、状态序列、输出序列

## 密钥流产生器



## 线性反馈移位寄存器（LFSR）

周期

n级线性移位反馈寄存器，**m序列：周期等于2^n^-1**

## 线性移位寄存器的一元多项式表示



递推关系。![image-20231023094228615](assets/image-20231023094228615.png)

LFSR的**特征多项式**：p(x)=1+c~1~x+c~2~x^2^+……+c~n-1~x^n-1^+c~n~x^n^

**G(p(x))**：n级线性移位寄存器的非恒零的2^n^-1个递推序列

给定序列{a~i~}，幂级数![image-20231022213434626](assets/image-20231022213434626.png)称为该序列的**生成函数**。

设p(x)=1+c~1~x+c~2~x^2^+……+c~n-1~x^n-1^+c~n~x^n^是GF(2)上的多项式，G(p(x))中任一序列{a~i~}的生成函数A(x)满足![image-20231022214849745](assets/image-20231022214849745.png)

p(x)|q(x)的充要条件G(p(x))⊂G(q(x))

设p(x)是GF(2)上的多项式，使p(x)|(x^p^-1)的最小p称为p(x)的周期或阶

若序列{a~i~}的特征多项式p(x)定义在GF(2)上，p使p(x)的周期，则{a~i~}的周期r|p。

仅能被非0常数或自身的常数倍除尽，但不能被其他多项式除尽的多项式称为即约多项式或不可约多项式

设p(x)是n次不可约多项式，周期为m，序列{a~i~}∈G(p(x))，则{a~i~}的周期为m。

n级LSFR产生的序列有最大周期2^n^-1的必要条件是其特征多项式不可约。

若n次不可约多项式p(x)的阶为2^n^-1，则p(x)是n次 本原多项式。

设{a~i~}∈G(p(x))，{a~i~}为m序列的充分条件是p(x)为本原多项式。

游程

GF(2)上周期为T的序列{a~i~}的自相关函数为![image-20231023092531595](assets/image-20231023092531595.png)

![image-20231023092544075](assets/image-20231023092544075.png)

![image-20231023092710465](assets/image-20231023092710465.png)

![image-20231023092746546](assets/image-20231023092746546.png)

## 非线性序列

### Geffe序列生成器

LFSR~i~的特征多项式分别为n~i~次本原多项式，且n~i~两两互素，则Geffe序列的周期为![image-20231023141427824](assets/image-20231023141427824.png)

![image-20231023141532782](assets/image-20231023141532782.png)

![image-20231023141630476](assets/image-20231023141630476.png)

### 利用JK触发器的非线性序列生成器

![image-20231023141733965](assets/image-20231023141733965.png)

![image-20231023141743097](assets/image-20231023141743097.png)

![image-20231023141934037](assets/image-20231023141934037.png)

![image-20231023142409523](assets/image-20231023142409523.png)![image-20231023142420734](assets/image-20231023142420734.png)

![image-20231023143613629](assets/image-20231023143613629.png)

### Pless生成器

![image-20231023150041906](assets/image-20231023150041906.png)

### 钟控序列生成器

![image-20231023150159863](assets/image-20231023150159863.png)

# 分组密码体制

![image-20231024200607989](assets/image-20231024200607989.png)

DES采用56比特密钥、IDEA采用128比特密钥

## 代换

![image-20231024200711302](assets/image-20231024200711302.png)

![image-20231024200726102](assets/image-20231024200726102.png)

S盒

![image-20231024200831601](assets/image-20231024200831601.png)

## 扩散和混淆

目的是抗击敌手对密码系统的统计分析。

扩散，就是将明文的统计特性散布到密文中去，实现方式是使得密文中每一位由明文中多位产生。

扩散的目的是使明文和密文之间的统计关系变得尽可能复杂，以使敌手无法得到密钥。

混淆是使密文和密钥之间的统计关系变得尽可能复杂，以使敌手无法得到密钥。因此即使敌手能得到密文的一些统计关系，由于密钥和密文之间统计关系复杂化，敌手无法得到密钥。使用复杂的代换算法可得预期的混淆效果，而简单的线性代换函数得到的混淆效果不够理想。

## Feistel密码结构

Feistel提出利用**乘积密码**可获得简单的代换密码。乘积密码指顺序地执行两个或多个基本密码系统，使得最后结果的密码强度高于每个基本密码系统产生的结果。

![image-20231024201716825](assets/image-20231024201716825.png)

![image-20231024201724748](assets/image-20231024201724748.png)

Feistel网络的实现与以下参数和特性有关：
(1)分组大小。分组越大则安全性越高，但加密速度就越慢。分组密码设计中最为普遍使用的分组大小是64比特。
(2)密钥大小。密钥越长则安全性越高，但加密速度就越慢。现在普遍认为64比特或更短的密钥是不安全的，通常使用128比特长的密钥。(3)轮数。单轮结构远不足以保证安全性，多轮结构可提供足够的安全性。典型地，轮数取为16。
(4)子密钥产生算法。该算法的复杂性越高，则密码分析的困难性就越大。
(5)轮函数。轮函数的复杂性越高，密码分析的困难性也越大。

在设计Feistel网络时，还要考虑以下两个问题：
(1)快速的软件实现。在很多情况下，算法是被镶嵌在应用程序中，因而无法用硬件实现。此时算法的执行速度是考虑的关键。
(2)算法容易分析。如果算法能被无疑义地解释清楚，就可容易地分析算法抵抗攻击的能力，有助于设计高强度的算法。

![image-20231024201845568](assets/image-20231024201845568.png)

![image-20231024202227925](assets/image-20231024202227925.png)

![image-20231024202223120](assets/image-20231024202223120.png)

## 数据加密标准（DES）

分组长度64比特
密钥长度56比特

三个阶段：

1. 初始置换IP
2. 16轮变换
3. 逆初始

从而产生64比特的密文。

密钥首先通过一个置换函数，然后，对加密过程的每一轮，通过一个左循环移位和一个置换产生一个子密钥。其中每轮的置换都相同，但由于密钥被重复迭代，所以每轮产生的子密钥都不相同。

![image-20231024204236191](assets/image-20231024204236191.png)

### 初始置换

初始置换输入64bit，每一位bit按其位对应表中的数值进行移位，如第1位换到第58位，第二位换到第50位

![image-20231024204308474](assets/image-20231024204308474.png)

![image-20231024204342335](assets/image-20231024204342335.png)

![image-20231024204352636](assets/image-20231024204352636.png)

### 轮结构

![image-20231024210010929](assets/image-20231024210010929.png)

![image-20231024210025244](assets/image-20231024210025244.png)

扩展将32比特变为48比特。

![image-20231024210700290](assets/image-20231024210700290.png)

![image-20231024210706272](assets/image-20231024210706272.png)

8个S盒，每个S盒的输入为6比特，输出为4比特。八个S盒一共48比特输入后输出一共32比特。

![image-20231024211011954](assets/image-20231024211011954.png)

![image-20231024211121223](assets/image-20231024211121223.png)

### 密钥的产生

56比特密钥先经过一个置换运算。

分两部分，进入轮函数，各进行循环左移位，移位位数由表给出，得到的输出①作为下一轮输入；②进行置换选择2后作为本轮子密钥。

![image-20231024211246324](assets/image-20231024211246324.png)

![image-20231024210010929](assets/image-20231024210010929.png)

![image-20231024211349991](assets/image-20231024211349991.png)

![image-20231024211401468](assets/image-20231024211401468.png)

### 解密

和Feistel密码一样，DES的解密和加密使用同一算法，但子密钥使用的顺序相反。

### 二重DES

![image-20231024212153604](assets/image-20231024212153604.png)

**二重DES产生的映射不会等价于单重DES加密。**

#### 中途相遇攻击

但对二重DES有以下一种称为**中途相遇攻击**的攻击方案，已知明文密文对![image-20231024212445539](assets/image-20231024212445539.png)

### 两个密钥的三重DES

![image-20231024213203675](assets/image-20231024213203675.png)

### 3个密钥的三重DES

 	![image-20231024213301296](assets/image-20231024213301296.png)

![image-20231024213305911](assets/image-20231024213305911.png)

## 差分密码分析

差分密码分析的基本思想：通过分析明文对的差值对密文对的差值的影响来恢复某些密钥比特。

一种攻击的复杂度可以分为两部分：**数据复杂度**和**处理复杂度**。数据复杂度是实施该攻击所需输人的数据量；处理复杂度是处理这些数据所需的计算量。这两部分主要用来刻画该攻击的复杂度。

## 线性密码分析

线性密码分析是对迭代密码的一种已知明文攻击，它利用的是密码算法中的“不平衡（有效）的线性逼近”。

## 分组密码的运行模式

![image-20231024214031325](assets/image-20231024214031325.png)

### 电码本(ECB)模式

一次对一个64比特长的明文分组加密，而且**每次的加密密钥都相同**，

如图3-10所示。当密钥取定时，对明文的每一个分组，都有一个唯一的密文与之对应。因此可以形象地认为有一个非常大的
电码本，对任意一个可能的明文分组，电码本中都有一项与之对应的密文。

如果消息长于64比特，则将其分为长为64比特的分组，最后一个分组如果不够64比特，则需要**填充**。

解密过程也是一次对一个分组解密，而且每次解密都使用同一密钥。

![image-20231024214651823](assets/image-20231024214651823.png)

ECB在用于短数据（如加密密钥）时非常理想，因此如果需要安全地传递DES密钥，ECB是最合适的模式。

ECB的最大特性是若同一明文分组在消息中重复出现，则产生的密文分组也相同。

ECB用于长消息时可能不够安全，如果消息有固定结构，密码分析者有可能找出这种关系。例如，如果已知消息总是以某个预定义字段开始，那么分析者就可能得到很多明文密文对。如果消息有重复的元素而重复的周期是64的倍数，那么密码分析者就能够识别这些元素。以上这些特性都有助于密码分析者，有可能为其提供对分组的代换或重排的机会。

### 密码分组链接（CBC）模式

为了解决ECB的安全缺陷，可以让重复的明文分组产生不同的密文分组，密码分组链接(Cipher Block Chaining,CBC)模式就可满足这一要求。
图3-11是CBC模式的示意图，它一次对一个明文分组加密，**每次加密使用同一密钥，加密算法的输入是当前明文分组和前一次密文分组的异或**，因此加密算法的输入不会显示出与这次的明文分组之间的固定关系，所以重复的明文分组不会在密文中暴露出这
种重复关系。
解密时，每一个密文分组被解密后，再与前一个密文分组异或，即：

![image-20231024214945646](assets/image-20231024214945646.png)

因而产生出明文分组。
在产生第一个密文分组时，需要有一个初始向量V与第一个明文分组异或。解密时，IV和解密算法对第一个密文分组的输出进行异或以恢复第一个明文分组。

![image-20231024214922890](assets/image-20231024214922890.png)

IV对于收发双方都应是已知的，为使安全性最高，**IV应像密钥一样被保护，可使用ECB加密模式来发送IV**。保护IV的原因如下：如果敌手能欺骗接收方使用不同的IV值，敌手就能够在明文的第一个分组中插入自己选择的比特值，这是因为：
![image-20231024215048460](assets/image-20231024215048460.png)
用X(i)表示64比特分组X的第i个比特，那么![image-20231024215117572](assets/image-20231024215117572.png),由异或的性质得：
![image-20231024215135074](assets/image-20231024215135074.png)

其中撇号表示比特补。上式意味着如果敌手篡改了IV中的某些比特，则接收方收到的P~1~中相应的比特也发生变化。

由于CBC模式的链接机制，CBC模式对加密长于64比特的消息非常合适。

CBC模式除能够获得保密性外，还能用于**认证**。

### 密码反馈(CFB)模式

如上所述，DES是分组长为64比特的分组密码，但**利用密码反馈(Cipher FeedBack,CFB)模式或输出反馈模式(OFB)模式可将DES转换为流密码**。流密码不需要对消息填充，而且运行是实时的。因此如果传送字母流，可使用流密码对每个字母直接加密并传送。
流密码具有密文和明文一样长这一性质，因此，如果需要发送的每个字符长为8比特，就应使用8比特密钥来加密每个字符。如果密钥长超过8比特，则造成浪费。
图3-12是CFB模式示意图，设传送的每个单元（如一个字符）是j比特长，通常取j=8,与CBC模式一样，明文单元被链接在一起，使得密文是前面所有明文的函数。
![image-20231024215409472](assets/image-20231024215409472.png)

加密时，加密算法的输入是64比特移位寄存器，其初值为某个初始向量IV。加密算法输出的最左（最高有效位）j比特与明文的第一个单元P~1~异或，产生出密文的第一个单元C~1~,并传送该单元。然后将移位寄存器的内容左移j位并将C~1~送入移位寄存器最右边（最低有效位）j位。这一过程继续到明文的所有单元都被加密为止。解密时，将收到的密文单元与加密函数的输出进行异或。注意这时仍然使用加密算
法而不是解密算法，原因如下：
设S,(X)是X的j个最高有效位，那么![image-20231024215603220](assets/image-20231024215603220.png),因此![image-20231024215620132](assets/image-20231024215620132.png)可证明以后各步也有类似的这种关系。

CFB模式除能获得保密性外，还能用于认证。

### 输出反馈（OFB）模式

输出反馈(Output FeedBack,OFB)模式的结构类似于CFB,如图3-l3所示。不同之处如下：**OFB模式是将加密算法的输出反馈到移位寄存器，而CFB模式是将密文单元反馈到移位寄存器。**

![image-20231024220031545](assets/image-20231024220031545.png)

OFB模式的优点是**传输过程中的比特错误不会被传播。**例如，C~1~中出现一比特错误，在解密结果中只有P~1~受到影响，以后各明文单元则不受影响。而在CFB中，C~1~也作为移位寄存器的输人，因此它的一比特错误会影响解密结果中各明文单元的值。
OFB的缺点是它**比CFB模式更易受到对消息流的篡改攻击**，例如在密文中取1比特的补，那么在恢复的明文中相应位置的比特也为原比特的补。因此使得敌手有可能通过对消息校验部分的篡改和对数据部分的篡改，而以纠错码不能检测的方式篡改密文。

## AES
